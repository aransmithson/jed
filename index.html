<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Jed in Space</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
<style>
* { box-sizing: border-box; }
body { margin:0; overflow:hidden; background:#000; font-family:'Share Tech Mono', monospace; cursor:crosshair; }
canvas { display:block; }

/* ‚îÄ‚îÄ CRT scanline overlay ‚îÄ‚îÄ */
body::after {
    content:'';
    position:fixed;
    inset:0;
    background: repeating-linear-gradient(
        0deg,
        rgba(0,0,0,0.03) 0px,
        rgba(0,0,0,0.03) 1px,
        transparent 1px,
        transparent 3px
    );
    pointer-events:none;
    z-index:999;
}
body::before {
    content:'';
    position:fixed;
    inset:0;
    background: radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,0.55) 100%);
    pointer-events:none;
    z-index:998;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   START SCREEN
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
#start-screen {
    position: fixed;
    inset: 0;
    z-index: 500;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: transparent;
    pointer-events: auto;
    transition: opacity 0.8s ease;
}
#start-screen.hidden {
    opacity: 0;
    pointer-events: none;
}

#start-title {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(36px, 8vw, 72px);
    font-weight: 700;
    letter-spacing: clamp(6px, 2vw, 16px);
    color: #fff;
    text-transform: uppercase;
    text-align: center;
    position: relative;
    margin-bottom: 4px;
    text-shadow:
        0 0 20px rgba(0,170,255,0.8),
        0 0 40px rgba(0,170,255,0.4),
        0 0 80px rgba(0,170,255,0.2),
        0 0 120px rgba(0,100,255,0.1);
    animation: title-glow 3s ease-in-out infinite, title-float 6s ease-in-out infinite;
}
#start-title .highlight {
    color: #0af;
    text-shadow:
        0 0 20px rgba(0,170,255,1),
        0 0 40px rgba(0,170,255,0.6),
        0 0 80px rgba(0,170,255,0.3);
}

@keyframes title-glow {
    0%, 100% { filter: brightness(1); }
    50% { filter: brightness(1.2); }
}
@keyframes title-float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-6px); }
}


#start-subtitle {
    font-family: 'Share Tech Mono', monospace;
    font-size: clamp(9px, 1.8vw, 13px);
    letter-spacing: clamp(4px, 1vw, 10px);
    color: rgba(0,170,255,0.5);
    text-transform: uppercase;
    margin-bottom: 5px;
    animation: subtitle-fade 2s ease-in-out infinite alternate;
}
@keyframes subtitle-fade {
    from { opacity: 0.4; }
    to { opacity: 0.8; }
}

/* Characters area ‚Äî canvas drawn Jed + Rocket */
#start-characters {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: clamp(20px, 6vw, 80px);
    margin-bottom: 36px;
    position: relative;
}

#start-canvas {
    width: clamp(280px, 60vw, 500px);
    height: clamp(180px, 30vw, 260px);
}

/* Explainer text */
#start-explainer {
    text-align: center;
    max-width: 420px;
    padding: 0 20px;
    margin-bottom: 36px;
}
#start-explainer p {
    font-family: 'Share Tech Mono', monospace;
    font-size: clamp(10px, 1.6vw, 13px);
    line-height: 1.9;
    letter-spacing: 1.5px;
    color: rgba(165,225,255,0.7);
    margin: 0 0 8px 0;
}
#start-explainer .em {
    color: #0af;
}
#start-explainer .warn {
    color: #ff6644;
}

/* Launch button */
#start-btn {
    font-family: 'Orbitron', sans-serif;
    font-size: clamp(11px, 2vw, 15px);
    letter-spacing: clamp(4px, 1vw, 8px);
    text-transform: uppercase;
    background: transparent;
    border: 1.5px solid rgba(0,170,255,0.5);
    color: #0af;
    padding: clamp(12px, 2vw, 18px) clamp(28px, 5vw, 50px);
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
    text-shadow: 0 0 12px rgba(0,170,255,0.6);
}
#start-btn:hover {
    background: rgba(0,170,255,0.1);
    border-color: #0af;
    box-shadow:
        0 0 20px rgba(0,170,255,0.3),
        inset 0 0 20px rgba(0,170,255,0.05);
    transform: scale(1.04);
    letter-spacing: clamp(5px, 1.2vw, 10px);
}
#start-btn:active {
    transform: scale(0.97);
    background: rgba(0,170,255,0.2);
}
/* Sweep animation on button */
#start-btn::before {
    content: '';
    position: absolute;
    top: 0; left: -100%;
    width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(0,170,255,0.15), transparent);
    animation: btn-sweep 3s ease-in-out infinite;
}
@keyframes btn-sweep {
    0% { left: -100%; }
    50% { left: 100%; }
    100% { left: 100%; }
}

/* Intro label under characters */
#start-intro {
    font-family: 'Share Tech Mono', monospace;
    font-size: clamp(9px, 1.6vw, 12px);
    letter-spacing: 3px;
    color: rgba(180,235,255,0.85);
    text-transform: uppercase;
    margin-bottom: 8px;
    text-align: center;
    text-shadow: 0 0 10px rgba(0,170,255,0.4);
}

/* Small version badge */
#start-version {
    position: fixed;
    bottom: 14px;
    right: 18px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 8px;
    letter-spacing: 2px;
    color: rgba(0,170,255,0.2);
    z-index: 501;
}


/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   HUD ‚Äî horizontal top bar
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
#hud {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 10;
    pointer-events: none;
}

#hud-panel {
    background: rgba(0,5,16,0.92);
    border-bottom: 1px solid rgba(0,170,255,0.3);
    padding: 10px 18px;
    display: flex;
    align-items: center;
    gap: 16px;
    position: relative;
}
/* Blue glow line along the bottom */
#hud-panel::after {
    content: '';
    position: absolute;
    bottom: 0; left: 0; right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, rgba(0,170,255,0.7) 50%, transparent);
}

/* ‚îÄ‚îÄ Title badge ‚îÄ‚îÄ */
#hud-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    letter-spacing: 4px;
    color: rgb(165, 225, 255);
    opacity: 1;
    white-space: nowrap;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: 6px;
}
#hud-title::before {
    content: '‚óà';
    animation: hud-blink 2s ease-in-out infinite;
}
@keyframes hud-blink { 0%,100%{ opacity:1; } 50%{ opacity:0.2; } }

/* ‚îÄ‚îÄ Resource bars ‚îÄ‚îÄ */
#hud-resources {
    display: flex;
    gap: 12px;
    flex: 1;
    min-width: 0;
}

.res-col {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.res-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    letter-spacing: 2px;
    color: rgb(165, 225, 255);
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    text-transform: uppercase;
}
.res-val {
    font-family: 'Orbitron', sans-serif;
    font-size: 11px;
    color: rgb(165, 225, 255);
    letter-spacing: 0;
    line-height: 1;
}

.res-track {
    width: 100%;
    height: 7px;
    background: rgba(0,170,255,0.07);
    position: relative;
    border: 1px solid rgba(0,170,255,0.15);
    border-radius: 1px;
}
.res-fill {
    height: 100%;
    border-radius: 1px;
    transition: width 0.4s ease;
    position: relative;
}
/* Bright leading edge */
.res-fill::after {
    content: '';
    position: absolute;
    right: 0; top: 0; bottom: 0;
    width: 2px;
    background: rgba(255,255,255,0.85);
    box-shadow: 0 0 5px currentColor;
    border-radius: 1px;
}
/* Tick marks at 25% intervals */
.res-track::before {
    content: '';
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(
        90deg,
        transparent 0%,
        transparent calc(25% - 1px),
        rgba(0,170,255,0.18) calc(25% - 1px),
        rgba(0,170,255,0.18) 25%
    );
    z-index: 1;
    pointer-events: none;
}

/* ‚îÄ‚îÄ CRITICAL state ‚Äî entire column pulses red ‚îÄ‚îÄ */
.res-col.critical .res-label { color: #ff5555; }
.res-col.critical .res-val   { color: #ff8888; animation: val-pulse 0.5s ease-in-out infinite alternate; }
.res-col.critical .res-track { border-color: rgba(255,60,60,0.45); background: rgba(255,20,20,0.08); }
.res-col.critical .res-fill  { animation: bar-pulse 0.5s ease-in-out infinite alternate; }

@keyframes val-pulse {
    from { opacity: 1; }
    to   { opacity: 0.4; }
}
@keyframes bar-pulse {
    from { filter: brightness(1.3); opacity: 1; }
    to   { filter: brightness(0.7); opacity: 0.35; }
}

/* ‚îÄ‚îÄ Divider ‚îÄ‚îÄ */
.hud-divider {
    width: 1px;
    height: 36px;
    background: rgba(0,170,255,0.15);
    flex-shrink: 0;
}

/* ‚îÄ‚îÄ Status & missions ‚îÄ‚îÄ */
#hud-meta {
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: 3px;
    align-items: flex-end;
}
.status-row {
    font-family: 'Share Tech Mono', monospace;
    font-size: 8px;
    letter-spacing: 2px;
    color: rgb(165, 225, 255);;
    text-transform: uppercase;
    white-space: nowrap;
}
.status-val { color: #0af; }

#missions-wrap {
    display: flex;
    align-items: center;
    gap: 5px;
    margin-top: 2px;
}
#missions-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 8px;
    letter-spacing: 2px;
    color: #2e5a78;
    text-transform: uppercase;
}
#missions-count {
    font-family: 'Orbitron', sans-serif;
    font-size: 13px;
    color: #44ff88;
    letter-spacing: 1px;
}

/* ‚îÄ‚îÄ Controls ‚îÄ‚îÄ */
#hud-controls {
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    gap: 4px;
    pointer-events: auto;
}
#speed-controls {
    display: none;
    gap: 3px;
}
#speed-controls.visible { display: flex; }

.speed-btn {
    font-family: 'Share Tech Mono', monospace;
    font-size: 8px;
    letter-spacing: 1px;
    text-transform: uppercase;
    background: rgba(0,170,255,0.05);
    border: 1px solid rgba(0,170,255,0.2);
    color: #4a7a9a;
    padding: 3px 7px;
    cursor: pointer;
    transition: all 0.15s;
}
.speed-btn:hover { background: rgba(0,170,255,0.12); color: #8af; }
.speed-btn.active { background: rgba(0,170,255,0.18); border-color: #0af; color: #0af; box-shadow: 0 0 6px rgba(0,170,255,0.3); }

#follow-btn {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 15;
    font-family: 'Share Tech Mono', monospace;
    font-size: 11px;
    font-weight: bold;
    letter-spacing: 2px;
    text-transform: uppercase;
    background: rgba(0,10,25,0.9);
    border: 1px solid rgba(0,170,255,0.35);
    color: #4a7a9a;
    padding: 8px 14px;
    cursor: pointer;
    transition: all 0.2s;
    white-space: nowrap;
    pointer-events: auto;
}
#follow-btn:hover, #follow-btn.active {
    background: rgba(0,170,255,0.15);
    border-color: #0af;
    color: #0af;
    box-shadow: 0 0 10px rgba(0,170,255,0.25);
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   Notifications ‚Äî just below HUD
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
#notif-container {
    position: fixed;
    top: 68px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    pointer-events: none;
    z-index: 50;
}
.notif {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    letter-spacing: 3px;
    text-transform: uppercase;
    padding: 6px 20px;
    border: 1px solid;
    background: rgba(0,0,0,0.85);
    animation: notif-in 0.2s ease-out, notif-out 0.4s ease-in 1.8s forwards;
    white-space: nowrap;
}
.notif.event-major {
    font-size: 12px;
    letter-spacing: 4px;
    padding: 8px 24px;
    animation: notif-in 0.2s ease-out, notif-out 0.5s ease-in 2.8s forwards;
}
@keyframes notif-in {
    from { opacity:0; transform: scaleX(0.7) translateY(-6px); }
    to   { opacity:1; transform: scaleX(1) translateY(0); }
}
@keyframes notif-out {
    from { opacity:1; }
    to   { opacity:0; transform: translateY(-10px); }
}

/* ‚îÄ‚îÄ Tap hint ‚îÄ‚îÄ */
#tap-hint {
    position: fixed;
    bottom: 22px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    letter-spacing: 4px;
    color: #0af;
    text-transform: uppercase;
    pointer-events: none;
    z-index: 10;
    text-shadow: 0 0 12px rgba(0,170,255,0.8);
    animation: tap-hint-pulse 2s ease-in-out infinite;
    white-space: nowrap;
}
#tap-hint.hidden { display: none; }
@keyframes tap-hint-pulse { 0%,100%{ opacity:0.9; } 50%{ opacity:0.3; } }

/* ‚îÄ‚îÄ Zoom hint ‚îÄ‚îÄ */
#zoom-hint {
    position: fixed;
    top: 68px;
    right: 16px;
    font-size: 7px;
    letter-spacing: 2px;
    color: #1a2a3a;
    pointer-events: none;
    z-index: 10;
}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   MOBILE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
@media (max-width: 680px) {
    /* Stack into two rows: bars on top, status on bottom */
    #hud-panel {
        flex-wrap: wrap;
        padding: 8px 12px 6px;
        gap: 8px;
    }
    #hud-title { order: 1; flex-basis: 100%; margin-bottom: 0; }
    #hud-resources { order: 2; flex-basis: 100%; gap: 8px; }
    .hud-divider { display: none; }
    #hud-meta { order: 3; flex-direction: row; align-items: center; gap: 12px; flex: 1; }
    #hud-controls { order: 4; flex-direction: row; }

    .res-label { font-size: 8px; }
    .res-val { font-size: 10px; }
    .res-track { height: 6px; }

    #notif-container { top: 100px; }
    #zoom-hint { top: 100px; }
}

@media (max-width: 480px) {
    #hud-title { display: none; }
    #hud-panel { padding: 7px 10px 5px; gap: 6px; }
    #hud-resources { gap: 6px; }
    .res-label { font-size: 7px; letter-spacing: 1px; }
    .res-val { font-size: 9px; }
    .res-track { height: 5px; }
    #notif-container { top: 88px; }
    .notif { font-size: 8px; letter-spacing: 2px; padding: 4px 12px; }
    .notif.event-major { font-size: 9px; padding: 5px 14px; }
    #tap-hint { font-size: 8px; letter-spacing: 2px; }
}

@media (max-width: 360px) {
    #missions-wrap { display: none; }
    #hud-meta .status-row:last-child { display: none; }
}

/* ‚îÄ‚îÄ Mute button ‚îÄ‚îÄ */
#mute-btn {
    position: fixed;
    bottom: 20px;
    left: 130px;
    z-index: 600;
    font-family: 'Share Tech Mono', monospace;
    font-size: 16px;
    background: rgba(0,10,25,0.9);
    border: 1px solid rgba(0,170,255,0.35);
    color: #4a7a9a;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
    pointer-events: auto;
    line-height: 1;
}
#mute-btn:hover {
    background: rgba(0,170,255,0.15);
    border-color: #0af;
    color: #0af;
    box-shadow: 0 0 10px rgba(0,170,255,0.25);
}
#mute-btn.muted {
    color: #ff4466;
    border-color: rgba(255,68,102,0.4);
}
#mute-btn.muted:hover {
    background: rgba(255,68,102,0.1);
    border-color: #ff4466;
    box-shadow: 0 0 10px rgba(255,68,102,0.2);
}
/* Push mute button on mobile */
@media (max-width: 680px) {
    #mute-btn { left: 130px; }
}

/* ‚îÄ‚îÄ Planet navigation bar (follow-cam mode) ‚îÄ‚îÄ */
#planet-nav {
    position: fixed;
    bottom: 64px;
    left: 20px;
    z-index: 15;
    display: flex;
    flex-direction: column;
    gap: 4px;
    pointer-events: auto;
    background: rgba(0,5,16,0.92);
    border: 1px solid rgba(0,170,255,0.28);
    padding: 10px 8px 8px;
    min-width: 100px;
    max-height: calc(100vh - 120px);
    overflow-y: auto;
    overflow-x: hidden;
    transform: translateX(-110%);
    transition: transform 0.32s cubic-bezier(0.22, 1, 0.36, 1),
                opacity 0.28s ease;
    opacity: 0;
    box-shadow: 4px 0 24px rgba(0,0,0,0.6), 0 0 16px rgba(0,170,255,0.08);
}
#planet-nav.visible {
    transform: translateX(0);
    opacity: 1;
}
#planet-nav::before {
    content: 'NAV';
    font-family: 'Share Tech Mono', monospace;
    font-size: 7px;
    letter-spacing: 3px;
    color: rgba(0,170,255,0.4);
    text-align: center;
    margin-bottom: 4px;
    display: block;
    padding-bottom: 5px;
    border-bottom: 1px solid rgba(0,170,255,0.12);
}
/* Custom scrollbar */
#planet-nav::-webkit-scrollbar { width: 3px; }
#planet-nav::-webkit-scrollbar-track { background: transparent; }
#planet-nav::-webkit-scrollbar-thumb { background: rgba(0,170,255,0.2); border-radius: 2px; }

.planet-nav-btn {
    font-family: 'Share Tech Mono', monospace;
    font-size: 9px;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    border: 1px solid;
    background: rgba(0,10,25,0.7);
    padding: 7px 10px;
    cursor: pointer;
    transition: background 0.15s, box-shadow 0.15s, transform 0.1s, border-color 0.2s;
    white-space: nowrap;
    text-align: left;
    width: 100%;
    position: relative;
    overflow: hidden;
    -webkit-tap-highlight-color: transparent;
    min-height: 36px; /* mobile touch target */
}
.planet-nav-btn::before {
    content: '‚ñ∏ ';
    opacity: 0.5;
    font-size: 7px;
}
.planet-nav-btn::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.04), transparent);
    transform: translateX(-100%);
    transition: transform 0s;
}
.planet-nav-btn:hover::after,
.planet-nav-btn:active::after {
    transform: translateX(100%);
    transition: transform 0.4s ease;
}
.planet-nav-btn:hover {
    filter: brightness(1.5);
    box-shadow: 0 0 10px currentColor, inset 0 0 8px rgba(255,255,255,0.04);
    transform: translateX(2px);
}
.planet-nav-btn:active {
    transform: translateX(1px) scale(0.97);
}
.planet-nav-btn.active-target {
    filter: brightness(1.8);
    box-shadow: 0 0 12px currentColor;
}
.planet-nav-btn.active-target::before {
    content: '‚óè ';
    opacity: 1;
    animation: nav-dot-pulse 0.8s ease-in-out infinite alternate;
}
@keyframes nav-dot-pulse {
    from { opacity: 1; }
    to   { opacity: 0.3; }
}
/* Stagger animation for each button when nav opens */
.planet-nav-btn:nth-child(2) { animation-delay: 0.04s; }
.planet-nav-btn:nth-child(3) { animation-delay: 0.08s; }
.planet-nav-btn:nth-child(4) { animation-delay: 0.12s; }
.planet-nav-btn:nth-child(5) { animation-delay: 0.16s; }
.planet-nav-btn:nth-child(6) { animation-delay: 0.20s; }

#planet-nav.visible .planet-nav-btn {
    animation: nav-btn-in 0.3s ease both;
}
@keyframes nav-btn-in {
    from { opacity: 0; transform: translateX(-12px); }
    to   { opacity: 1; transform: translateX(0); }
}

/* ‚îÄ‚îÄ Mobile adjustments ‚îÄ‚îÄ */
@media (max-width: 680px) {
    #planet-nav {
        bottom: 64px;
        left: 20px;
        top: auto;
        /* Keep the same slide-in from left */
        transform: translateX(-110%);
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: flex-start;
        min-width: unset;
        max-width: calc(60vw);
        padding: 8px 6px 6px;
        gap: 5px;
        max-height: 160px;
    }
    #planet-nav.visible {
        transform: translateX(0);
        opacity: 1;
    }
    #planet-nav::before {
        width: 100%;
        text-align: center;
        margin-bottom: 2px;
    }
    .planet-nav-btn {
        font-size: 8px;
        padding: 6px 10px;
        min-height: 34px;
        width: auto;
    }
    #planet-nav.visible .planet-nav-btn {
        animation: nav-btn-in 0.3s ease both;
    }
}


/* ‚îÄ‚îÄ Game over ‚îÄ‚îÄ */
#gameover {
    display:none;
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.85);
    z-index:100;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    text-align:center;
}
#gameover.active { display:flex; }
#gameover-title {
    font-family:'Orbitron', sans-serif;
    font-size:32px;
    letter-spacing:8px;
    color:#ff3344;
    margin:0 0 6px 0;
    text-transform:uppercase;
    animation: glitch 3s infinite;
    position:relative;
}
#gameover-title::before, #gameover-title::after {
    content: attr(data-text);
    position:absolute;
    left:0; top:0;
    width:100%;
}
#gameover-title::before {
    color:#ff3344;
    animation: glitch-1 3s infinite;
    clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
}
#gameover-title::after {
    color:#0af;
    animation: glitch-2 3s infinite;
    clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
}
@keyframes glitch-1 {
    0%,95%,100%{ transform:translate(0); opacity:0; }
    96%{ transform:translate(-3px, 1px); opacity:0.8; }
    97%{ transform:translate(3px,-1px); opacity:0.8; }
    98%{ transform:translate(-1px,2px); opacity:0.8; }
    99%{ transform:translate(2px,-2px); opacity:0.8; }
}
@keyframes glitch-2 {
    0%,95%,100%{ transform:translate(0); opacity:0; }
    96%{ transform:translate(3px,-1px); opacity:0.7; }
    97%{ transform:translate(-2px,2px); opacity:0.7; }
    98%{ transform:translate(2px,1px); opacity:0.7; }
    99%{ transform:translate(-3px,-1px); opacity:0.7; }
}
#gameover-line {
    width:180px;
    height:1px;
    background:linear-gradient(90deg, transparent, #ff3344, transparent);
    margin:12px auto 16px;
}
#gameover p {
    font-size:10px;
    letter-spacing:3px;
    color:#666;
    margin:0 0 6px 0;
    text-transform:uppercase;
}
#gameover-score {
    font-family:'Orbitron', sans-serif;
    font-size:13px;
    letter-spacing:3px;
    color:#4f4;
    margin:0 0 28px 0;
}
.gameover-btn-row { display:flex; gap:12px; justify-content:center; }
#gameover button {
    font-family:'Share Tech Mono', monospace;
    font-size:10px;
    letter-spacing:3px;
    text-transform:uppercase;
    background:none;
    border:1px solid;
    padding:10px 22px;
    cursor:pointer;
    transition:all 0.2s;
}
#gameover button:first-child { border-color:#ff3344; color:#ff3344; }
#gameover button:first-child:hover { background:rgba(255,51,68,0.12); }
#gameover button:last-child { border-color:#3f3; color:#3f3; }
#gameover button:last-child:hover { background:rgba(51,255,51,0.08); }

#debug-panel {
    position:fixed;
    bottom:20px;
    left:20px;
    width:340px;
    max-height:260px;
    background:rgba(0,5,0,0.88);
    border:1px solid #1a3a1a;
    border-radius:4px;
    z-index:20;
    display:flex;
    flex-direction:column;
    font-family:'Share Tech Mono', monospace;
    font-size:9px;
    pointer-events:auto;
}
#debug-header {
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:5px 8px;
    border-bottom:1px solid #1a3a1a;
    background:rgba(0,40,0,0.6);
    cursor:pointer;
    user-select:none;
    letter-spacing:2px;
    color:#3f3;
    font-size:9px;
}
#debug-header span { color:#1a5c1a; }
#debug-log {
    overflow-y:auto;
    flex:1;
    padding:6px 8px;
    line-height:1.6;
}
#debug-log::-webkit-scrollbar { width:4px; }
#debug-log::-webkit-scrollbar-track { background:transparent; }
#debug-log::-webkit-scrollbar-thumb { background:#1a4a1a; border-radius:2px; }
.dl { color:#2a2a2a; }
.dl.info  { color:#3a7a3a; }
.dl.warn  { color:#aaaa00; }
.dl.crit  { color:#ff4444; }
.dl.state { color:#00aaff; }
.dl.score { color:#448844; }
.dl.skip  { color:#555; }
.dl.good  { color:#44ff44; }
#debug-panel.collapsed #debug-log { display:none; }
#debug-panel.hidden { display:none; }

/* ‚îÄ‚îÄ Fullscreen death debug overlay ‚îÄ‚îÄ */
#debug-overlay {
    display:none;
    position:fixed;
    inset:0;
    background:rgba(0,0,0,0.96);
    z-index:200;
    flex-direction:column;
    font-family:'Share Tech Mono', monospace;
}
#debug-overlay.active { display:flex; }
#debug-overlay-header {
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:14px 20px;
    border-bottom:1px solid #1a3a1a;
    background:rgba(0,30,0,0.8);
    flex-shrink:0;
}
#debug-overlay-title {
    font-family:'Orbitron', sans-serif;
    font-size:11px;
    letter-spacing:4px;
    color:#3f3;
    text-transform:uppercase;
    display:flex;
    align-items:center;
    gap:10px;
}
#debug-overlay-count {
    font-family:'Share Tech Mono', monospace;
    font-size:9px;
    letter-spacing:2px;
    color:#1a5c1a;
}
#debug-overlay-controls {
    display:flex;
    gap:10px;
    align-items:center;
}
#debug-overlay-filter {
    font-family:'Share Tech Mono', monospace;
    font-size:9px;
    letter-spacing:2px;
    text-transform:uppercase;
    background:none;
    border:1px solid #1a4a1a;
    color:#2a6a2a;
    padding:4px 10px;
    cursor:pointer;
}
#debug-overlay-filter.active { color:#3f3; border-color:#3f3; }
#debug-overlay-close {
    font-family:'Share Tech Mono', monospace;
    font-size:11px;
    letter-spacing:2px;
    text-transform:uppercase;
    background:none;
    border:1px solid #ff3344;
    color:#ff3344;
    padding:4px 14px;
    cursor:pointer;
}
#debug-overlay-close:hover { background:rgba(255,51,68,0.12); }
#debug-overlay-log {
    flex:1;
    overflow-y:auto;
    padding:12px 20px;
    line-height:1.9;
    font-size:10px;
}
#debug-overlay-log::-webkit-scrollbar { width:5px; }
#debug-overlay-log::-webkit-scrollbar-track { background:transparent; }
#debug-overlay-log::-webkit-scrollbar-thumb { background:#1a4a1a; border-radius:3px; }

#debug-toggle-btn {
    position:fixed;
    bottom:20px;
    right:20px;
    font-family:'Share Tech Mono', monospace;
    font-size:9px;
    letter-spacing:2px;
    text-transform:uppercase;
    background:rgba(0,20,0,0.85);
    border:1px solid #1a5c1a;
    color:#3f3;
    padding:6px 10px;
    cursor:pointer;
    z-index:25;
    pointer-events:auto;
}
#debug-toggle-btn:hover { background:rgba(0,40,0,0.9); }

#debug-filter-btn {
    font-family:'Share Tech Mono', monospace;
    font-size:8px;
    letter-spacing:1px;
    text-transform:uppercase;
    background:none;
    border:1px solid #1a4a1a;
    color:#2a6a2a;
    padding:2px 6px;
    cursor:pointer;
    pointer-events:auto;
}
#debug-filter-btn.active { color:#3f3; border-color:#3f3; }
</style>
</head>
<body>
<canvas id="sim"></canvas>
<button id="follow-btn" style="display:none;">CAM: OFF</button>
<button id="mute-btn" style="display:none;" title="Toggle Sound">üîä</button>

<!-- Planet nav bar (shown in follow-cam mode) -->
<div id="planet-nav" style="display:none;"></div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     START SCREEN
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div id="start-screen">
    <div id="start-title"><span class="highlight">JED</span> IN SPACE</div>
    <div id="start-subtitle">‚óà an orbital survival mission ‚óà</div>

    <canvas id="start-canvas" width="500" height="260"></canvas>

    <div id="start-intro">MEET JED ‚Äî PILOT, EXPLORER, ALL ROUND COOL GUY</div>

    <div id="start-explainer">
        <p><span class="em">Tap planets</span> to fly there and resupply.</p>
        <p>Jed walks the surface, grabs the cargo, and loads up.</p>
        <p><span class="warn">Oxygen, water, food, fuel & hull</span> all drain ‚Äî keep them topped up.</p>
        <p>Random space events will try to kill you. <span class="em">Don't let them.</span></p>
    </div>

    <button id="start-btn" onclick="startGame()">‚óà LAUNCH MISSION ‚óà</button>

    <div id="start-version">V0.2 ‚Äî SOL 1</div>
</div>

<div id="hud" style="display:none;">
    <div id="hud-panel">

        <div id="hud-title">SHIP STATUS</div>

        <div id="hud-resources">
            <div class="res-col" id="row-oxygen">
                <div class="res-label"><span>OXYGEN</span><span class="res-val" id="val-oxygen">100</span></div>
                <div class="res-track"><div class="res-fill" id="bar-oxygen" style="background:linear-gradient(90deg,#0077bb,#00bbff);width:100%"></div></div>
            </div>
            <div class="res-col" id="row-water">
                <div class="res-label"><span>WATER</span><span class="res-val" id="val-water">100</span></div>
                <div class="res-track"><div class="res-fill" id="bar-water" style="background:linear-gradient(90deg,#1133aa,#3366ff);width:100%"></div></div>
            </div>
            <div class="res-col" id="row-food">
                <div class="res-label"><span>FOOD</span><span class="res-val" id="val-food">100</span></div>
                <div class="res-track"><div class="res-fill" id="bar-food" style="background:linear-gradient(90deg,#227744,#44dd77);width:100%"></div></div>
            </div>
            <div class="res-col" id="row-fuel">
                <div class="res-label"><span>FUEL</span><span class="res-val" id="val-fuel">100</span></div>
                <div class="res-track"><div class="res-fill" id="bar-fuel" style="background:linear-gradient(90deg,#aa6600,#ffaa00);width:100%"></div></div>
            </div>
            <div class="res-col" id="row-integrity">
                <div class="res-label"><span>HULL</span><span class="res-val" id="val-integrity">100</span></div>
                <div class="res-track"><div class="res-fill" id="bar-integrity" style="background:linear-gradient(90deg,#7722cc,#cc44ff);width:100%"></div></div>
            </div>
        </div>

        <div class="hud-divider"></div>

        <div id="hud-meta">
            <div class="status-row">STATE&nbsp;<span class="status-val" id="state-label">STANDBY</span></div>
            <div class="status-row">TARGET&nbsp;<span class="status-val" id="target-label">‚Äî</span></div>
            <div id="missions-wrap">
                <span id="missions-label">MISSIONS</span>
                <span id="missions-count">0</span>
            </div>
        </div>

        <div class="hud-divider"></div>

        <div id="hud-controls">
            <div id="speed-controls">
                <button class="speed-btn active" onclick="setSpeed(1)" id="spd1">1√ó</button>
                <button class="speed-btn" onclick="setSpeed(2)" id="spd2">2√ó</button>
                <button class="speed-btn" onclick="setSpeed(4)" id="spd4">4√ó</button>
            </div>
        </div>

    </div>
</div>

<div id="zoom-hint" style="display:none;">SCROLL/PINCH TO ZOOM &nbsp;¬∑&nbsp; DRAG TO PAN</div>

<div id="tap-hint" class="hidden">‚óà TAP A PLANET TO SET COURSE ‚óà</div>

<div id="debug-panel">
    <div id="debug-header" onclick="collapseDebug()">
        ‚óà DEBUG LOG <span id="debug-count">[0]</span>
        <button id="debug-filter-btn" onclick="event.stopPropagation(); toggleFilter()" title="Filter idle/skip entries">FILTER IDLE</button>
    </div>
    <div id="debug-log"></div>
</div>

<button id="debug-toggle-btn" onclick="toggleDebug()">‚óà DEBUG</button>

<div id="debug-overlay">
    <div id="debug-overlay-header">
        <div id="debug-overlay-title">
            ‚óà AI Debug Log ‚Äî Mission Debrief
            <span id="debug-overlay-count">[0]</span>
        </div>
        <div id="debug-overlay-controls">
            <button id="debug-overlay-filter" onclick="toggleOverlayFilter()">FILTER IDLE</button>
            <button id="debug-overlay-close" onclick="closeDebugOverlay()">‚úï CLOSE</button>
        </div>
    </div>
    <div id="debug-overlay-log"></div>
</div>

<div id="notif-container"></div>

<div id="gameover">
    <div id="gameover-title" data-text="Mission Failed">Mission Failed</div>
    <div id="gameover-line"></div>
    <p id="gameover-reason">Critical resource depleted</p>
    <div id="gameover-score"></div>
    <div class="gameover-btn-row">
        <button onclick="location.reload()">‚Ü∫ Restart</button>
        <button onclick="showDebugOnDeath()" style="margin-top:0;">‚äû Debug Log</button>
    </div>
</div>

<script>
const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d");

// =============================
// GAME STARTED FLAG
// =============================
let gameStarted = false;

// =============================
// START SCREEN CANVAS RENDERING
// =============================
const startCanvas = document.getElementById("start-canvas");
const sctx = startCanvas.getContext("2d");

function drawStartScreen(t){
    const dpr = window.devicePixelRatio || 1;
    const W = startCanvas.width / dpr;
    const H = startCanvas.height / dpr;
    sctx.clearRect(0, 0, W, H);

    // ‚îÄ‚îÄ Background: subtle star dust ‚îÄ‚îÄ
    sctx.globalAlpha = 0.4;
    for(let i = 0; i < 40; i++){
        const sx = (Math.sin(i * 73.7 + t * 0.0002) * 0.5 + 0.5) * W;
        const sy = (Math.cos(i * 51.3 + t * 0.00015) * 0.5 + 0.5) * H;
        const twinkle = 0.3 + 0.7 * Math.sin(t * 0.002 + i * 1.3);
        sctx.globalAlpha = 0.15 * twinkle;
        sctx.fillStyle = '#8af';
        sctx.beginPath();
        sctx.arc(sx, sy, 0.8, 0, Math.PI * 2);
        sctx.fill();
    }
    sctx.globalAlpha = 1;

    // ‚îÄ‚îÄ Ground line ‚îÄ‚îÄ
    const groundY = H - 30;

    // Hide ground during warp
    if(launchPhase !== 'warp' && launchPhase !== 'done'){
        sctx.strokeStyle = 'rgba(0,170,255,0.15)';
        sctx.lineWidth = 1;
        sctx.beginPath();
        sctx.moveTo(60, groundY);
        sctx.lineTo(W - 60, groundY);
        sctx.stroke();
        const gg = sctx.createLinearGradient(60, groundY - 2, 60, groundY + 8);
        gg.addColorStop(0, 'rgba(0,170,255,0.06)');
        gg.addColorStop(1, 'rgba(0,0,0,0)');
        sctx.fillStyle = gg;
        sctx.fillRect(60, groundY, W - 120, 10);
    }

    // ‚îÄ‚îÄ Animation state ‚îÄ‚îÄ
    const rocketHomeX = W * 0.50;
    const rocketHomeY = groundY;
    const jedHomeX = W * 0.18;
    const jedHomeY = groundY;
    const packagesX = W * 0.82;
    const packagesY = groundY;
    const rs = 2.4;
    const s = 1.6;

    // Compute animated positions
    let jedX = jedHomeX;
    let jedY = jedHomeY;
    let jedScale = s;
    let jedVisible = true;
    let jedWaving = true;
    let jedWalking = false;
    let rocketX = rocketHomeX;
    let rocketY = rocketHomeY;
    let rocketBob = Math.sin(t * 0.0015) * 3;
    let showLabels = true;
    let showExhaust = false;
    let exhaustIntensity = 0;
    let rocketScale = rs;

    if(launchPhase === 'walking'){
        const p = Math.min(1, launchTimer / 1500);
        const ease = p < 0.5 ? 2*p*p : 1 - Math.pow(-2*p+2,2)/2; // ease in-out
        jedX = jedHomeX + (rocketHomeX - jedHomeX) * ease;
        jedWaving = false;
        jedWalking = true;
        showLabels = false;
        rocketBob = Math.sin(t * 0.0015) * 3 * (1 - p);
    }
    else if(launchPhase === 'boarding'){
        const p = Math.min(1, launchTimer / 500);
        jedX = rocketHomeX;
        jedScale = s * (1 - p);
        jedY = jedHomeY - p * 20;
        jedWaving = false;
        jedWalking = false;
        showLabels = false;
        rocketBob = 0;
        if(p > 0.7) jedVisible = false;
    }
    else if(launchPhase === 'powerup'){
        const p = Math.min(1, launchTimer / 1500);
        jedVisible = false;
        showLabels = false;
        showExhaust = true;
        exhaustIntensity = p * p; // builds up
        rocketBob = 0;

        // Shake ‚Äî intensifies over time
        const shakeAmt = p * 4;
        rocketX = rocketHomeX + (Math.random() - 0.5) * shakeAmt;
        rocketY = rocketHomeY + (Math.random() - 0.5) * shakeAmt * 0.6;

        // Dust shaking off the ground
        if(Math.random() > 0.5){
            launchDust.push({
                x: rocketHomeX + (Math.random()-0.5) * 30,
                y: groundY + Math.random() * 4,
                vx: (Math.random()-0.5) * 2,
                vy: -Math.random() * 1.2,
                life: 1,
                size: 1 + Math.random() * 2.5,
            });
        }
    }
    else if(launchPhase === 'warp'){
        const p = Math.min(1, launchTimer / 800);
        jedVisible = false;
        showLabels = false;
        showExhaust = false;
        rocketBob = 0;

        // Draw warp streak at rocket position
        const warpEase = 1 - Math.pow(1-p, 2);
        sctx.save();
        // Clip to canvas bounds so warp streak stays inside
        sctx.beginPath();
        sctx.rect(0, 0, W, H);
        sctx.clip();
        sctx.translate(rocketHomeX, rocketHomeY);

        const streakW = warpEase * 350 + 10;
        const streakH = (1 - warpEase) * 30 + 2;
        const alpha = warpEase * 0.9;

        // Vertical warp streak
        const sg = sctx.createLinearGradient(0, -streakW, 0, streakW);
        sg.addColorStop(0,   'rgba(100,200,255,0)');
        sg.addColorStop(0.3, `rgba(140,220,255,${alpha * 0.5})`);
        sg.addColorStop(0.5, `rgba(220,240,255,${alpha})`);
        sg.addColorStop(0.7, `rgba(140,220,255,${alpha * 0.5})`);
        sg.addColorStop(1,   'rgba(100,200,255,0)');
        sctx.fillStyle = sg;
        sctx.fillRect(-streakH/2, -streakW, streakH, streakW*2);

        // Core line
        const cg = sctx.createLinearGradient(0, -streakW*0.6, 0, streakW*0.6);
        cg.addColorStop(0, 'rgba(255,255,255,0)');
        cg.addColorStop(0.5, `rgba(255,255,255,${alpha})`);
        cg.addColorStop(1, 'rgba(255,255,255,0)');
        sctx.fillStyle = cg;
        sctx.fillRect(-1, -streakW*0.6, 2, streakW*1.2);

        // Flash burst at start
        if(p < 0.3){
            const flashA = (0.3-p)/0.3;
            const flashR = (1-p) * 60;
            const fg = sctx.createRadialGradient(0,0,0, 0,0,flashR);
            fg.addColorStop(0, `rgba(255,255,255,${flashA*0.9})`);
            fg.addColorStop(0.4, `rgba(160,220,255,${flashA*0.5})`);
            fg.addColorStop(1, 'rgba(100,180,255,0)');
            sctx.fillStyle = fg;
            sctx.beginPath();
            sctx.arc(0, 0, flashR, 0, Math.PI*2);
            sctx.fill();
        }

        // Speed lines radiating out
        if(p < 0.5){
            const lineAlpha = (0.5 - p) / 0.5;
            sctx.strokeStyle = `rgba(180,230,255,${lineAlpha * 0.6})`;
            sctx.lineWidth = 0.8;
            for(let i = 0; i < 12; i++){
                const la = (i / 12) * Math.PI * 2;
                const inner = 15 + p * 20;
                const outer = inner + (1 - p) * 80 * (0.4 + Math.random() * 0.6);
                sctx.beginPath();
                sctx.moveTo(Math.cos(la) * inner, Math.sin(la) * inner);
                sctx.lineTo(Math.cos(la) * outer, Math.sin(la) * outer);
                sctx.stroke();
            }
        }

        sctx.restore();

        // Fade rocket out quickly
        if(p > 0.15){
            const rocketAlpha = Math.max(0, (0.3 - Math.min(0.3, p - 0.15)) / 0.3);
            drawRocket(sctx, rocketHomeX, rocketHomeY, 0, rocketScale, t, false, 0, false, rocketAlpha);
            drawLaunchDust(sctx, t);
            return;
        }
    }
    else if(launchPhase === 'done'){
        return;
    }

    // ‚îÄ‚îÄ Draw launch dust particles ‚îÄ‚îÄ
    drawLaunchDust(sctx, t);

    // ‚îÄ‚îÄ Draw resource packages (right side) ‚îÄ‚îÄ
    if(launchPhase === 'idle'){
        drawPackageStack(sctx, packagesX, packagesY, t);
    }

    // ‚îÄ‚îÄ Draw rocket ‚îÄ‚îÄ
    drawRocket(sctx, rocketX, rocketY + rocketBob, rocketBob, rocketScale, t, showExhaust, exhaustIntensity, showLabels, 1);

    // ‚îÄ‚îÄ Draw Jed ‚îÄ‚îÄ
    if(jedVisible && jedScale > 0.05){
        drawJed(sctx, jedX, jedY, jedScale, t, jedWaving, jedWalking, showLabels);
    }
}

// ‚îÄ‚îÄ Launch dust particle system ‚îÄ‚îÄ
let launchDust = [];

function drawLaunchDust(ctx2, t){
    for(let i = launchDust.length - 1; i >= 0; i--){
        const d = launchDust[i];
        d.x += d.vx;
        d.y += d.vy;
        d.vy += 0.02;
        d.vx *= 0.98;
        d.life -= 0.018;
        if(d.life <= 0){ launchDust.splice(i,1); continue; }
        ctx2.globalAlpha = d.life * 0.6;
        ctx2.fillStyle = '#aaccdd';
        ctx2.beginPath();
        ctx2.arc(d.x, d.y, d.size * d.life, 0, Math.PI*2);
        ctx2.fill();
    }
    ctx2.globalAlpha = 1;
}

// ‚îÄ‚îÄ Rocket drawing helper ‚îÄ‚îÄ
function drawRocket(ctx2, x, y, bob, sc, t, showExhaust, exInt, labels, alpha){
    if(alpha <= 0) return;
    ctx2.save();
    ctx2.globalAlpha = alpha;
    ctx2.translate(x, y);
    ctx2.scale(sc, sc);

    // Exhaust
    if(showExhaust && exInt > 0){
        const flameLen = 20 + Math.sin(t * 0.02) * 8;
        const fg = ctx2.createRadialGradient(0, 6, 2, 0, 6 + flameLen*0.5, flameLen*exInt);
        fg.addColorStop(0, `rgba(255,255,200,${0.9*exInt})`);
        fg.addColorStop(0.3, `rgba(255,160,40,${0.7*exInt})`);
        fg.addColorStop(0.6, `rgba(255,80,10,${0.4*exInt})`);
        fg.addColorStop(1, 'rgba(255,40,0,0)');
        ctx2.fillStyle = fg;
        ctx2.beginPath();
        ctx2.arc(0, 6 + flameLen*0.3*exInt, flameLen*exInt, 0, Math.PI*2);
        ctx2.fill();
    } else {
        // Idle shimmer
        const exGlow = ctx2.createRadialGradient(0, 2, 2, 0, 8, 20);
        exGlow.addColorStop(0, `rgba(255,160,40,${0.15 + 0.1 * Math.sin(t * 0.004)})`);
        exGlow.addColorStop(1, 'rgba(255,80,0,0)');
        ctx2.fillStyle = exGlow;
        ctx2.beginPath();
        ctx2.arc(0, 8, 20, 0, Math.PI * 2);
        ctx2.fill();
    }

    // Nozzle
    ctx2.fillStyle = '#667788';
    ctx2.fillRect(-5, -4, 10, 8);

    // Body
    ctx2.fillStyle = '#dde8f0';
    ctx2.beginPath();
    if(ctx2.roundRect) { ctx2.roundRect(-8, -44, 16, 42, 3); ctx2.fill(); }
    else { ctx2.fillRect(-8, -44, 16, 42); }

    // Cockpit
    ctx2.fillStyle = 'rgba(0,200,255,0.7)';
    ctx2.beginPath();
    ctx2.ellipse(0, -36, 5, 8, 0, 0, Math.PI * 2);
    ctx2.fill();

    // Wings
    ctx2.fillStyle = '#aabbc8';
    ctx2.beginPath();
    ctx2.moveTo(-8, -14); ctx2.lineTo(-20, -4); ctx2.lineTo(-8, -8);
    ctx2.closePath(); ctx2.fill();
    ctx2.beginPath();
    ctx2.moveTo(8, -14); ctx2.lineTo(20, -4); ctx2.lineTo(8, -8);
    ctx2.closePath(); ctx2.fill();

    // Label
    if(labels){
        ctx2.scale(1/sc, 1/sc);
        ctx2.font = "7px 'Share Tech Mono'";
        ctx2.fillStyle = 'rgba(0,170,255,0.5)';
        ctx2.textAlign = 'center';
        ctx2.fillText('THE SHIP', 0, -52 * sc);
    }

    ctx2.restore();
}

// ‚îÄ‚îÄ Jed drawing helper ‚îÄ‚îÄ
function drawJed(ctx2, x, y, sc, t, waving, walking, labels){
    ctx2.save();
    ctx2.translate(x, y);
    const bob = walking ? 0 : Math.sin(t * 0.002 + 1) * 2;
    ctx2.translate(0, bob);
    ctx2.scale(sc, sc);

    // Shadow
    ctx2.globalAlpha = 0.15;
    ctx2.fillStyle = '#0af';
    ctx2.beginPath();
    ctx2.ellipse(0, 2, 10, 3, 0, 0, Math.PI * 2);
    ctx2.fill();
    ctx2.globalAlpha = 1;

    // Legs
    if(walking){
        const step = Math.sin(t * 0.012);
        ctx2.fillStyle = '#aabbc8';
        ctx2.fillRect(-5 + step*2, -12, 4, 12 + step*2);
        ctx2.fillRect(1 - step*2, -12, 4, 12 - step*2);
    } else {
        const legSway = Math.sin(t * 0.0018) * 1;
        ctx2.fillStyle = '#aabbc8';
        ctx2.fillRect(-5 + legSway, -12, 4, 12);
        ctx2.fillRect(1 - legSway, -12, 4, 12);
    }

    // Body
    ctx2.fillStyle = '#dde8f0';
    ctx2.fillRect(-7, -30, 14, 20);

    // Backpack
    ctx2.fillStyle = '#99aabb';
    ctx2.fillRect(7, -28, 5, 14);

    // Left arm
    ctx2.fillStyle = '#ccd8e4';
    ctx2.save();
    ctx2.translate(-7, -26);
    if(walking){
        ctx2.rotate(Math.sin(t * 0.012) * 0.5);
    } else {
        ctx2.rotate(Math.sin(t * 0.002) * 0.08);
    }
    ctx2.fillRect(-4, 0, 4, 14);
    ctx2.restore();

    // Right arm
    ctx2.fillStyle = '#ccd8e4';
    ctx2.save();
    ctx2.translate(7, -28);
    if(waving){
        const upperArmAngle = -1.4;
        ctx2.rotate(upperArmAngle);
        ctx2.fillRect(0, 0, 4, 12);
        ctx2.translate(2, 12);
        const waveAngle = -Math.PI/2 + Math.sin(t * 0.008) * 0.7;
        ctx2.rotate(waveAngle);
        ctx2.fillRect(-2, 0, 4, 10);
        ctx2.fillStyle = '#dde8f0';
        ctx2.beginPath();
        ctx2.arc(0, 11, 3, 0, Math.PI * 2);
        ctx2.fill();
    } else if(walking){
        ctx2.rotate(-Math.sin(t * 0.012) * 0.5);
        ctx2.fillRect(0, 0, 4, 14);
    } else {
        ctx2.rotate(Math.sin(t * 0.002) * 0.08);
        ctx2.fillRect(0, 0, 4, 14);
    }
    ctx2.restore();

    // Helmet
    ctx2.fillStyle = 'rgba(200,230,255,0.95)';
    ctx2.beginPath();
    ctx2.arc(0, -38, 10, 0, Math.PI * 2);
    ctx2.fill();
    ctx2.fillStyle = 'rgba(0,160,255,0.45)';
    ctx2.beginPath();
    ctx2.arc(0, -37, 7, 0, Math.PI * 2);
    ctx2.fill();
    ctx2.fillStyle = 'rgba(255,255,255,0.3)';
    ctx2.beginPath();
    ctx2.ellipse(-2, -40, 3, 2, -0.3, 0, Math.PI * 2);
    ctx2.fill();

    // Antenna
    ctx2.strokeStyle = 'rgba(200,230,255,0.6)';
    ctx2.lineWidth = 1;
    ctx2.beginPath();
    ctx2.moveTo(0, -48);
    ctx2.lineTo(3, -56);
    ctx2.stroke();
    ctx2.fillStyle = t % 1200 < 600 ? '#0af' : '#066';
    ctx2.beginPath();
    ctx2.arc(3, -57, 2, 0, Math.PI * 2);
    ctx2.fill();

    // Label
    if(labels){
        ctx2.scale(1/sc, 1/sc);
        ctx2.font = "7px 'Share Tech Mono'";
        ctx2.fillStyle = 'rgba(0,170,255,0.5)';
        ctx2.textAlign = 'center';
        ctx2.fillText('JED', 0, -62 * sc);
    }

    ctx2.restore();
}

// ‚îÄ‚îÄ Package stack drawing helper (start screen) ‚îÄ‚îÄ
function drawPackageStack(ctx2, x, y, t){
    ctx2.save();
    const boxW = 18, boxH = 14;
    const colors = ['#ffaa00','#44dd77','#00bbff','#cc44ff'];
    // Draw 4 stacked crates
    for(let i = 0; i < 4; i++){
        const bx = x + (i % 2 === 0 ? -2 : 2);
        const by = y - i * (boxH - 2) - boxH;
        const col = colors[i];
        // Box body
        ctx2.fillStyle = col;
        ctx2.globalAlpha = 0.75 + 0.1 * Math.sin(t * 0.002 + i);
        ctx2.fillRect(bx - boxW/2, by, boxW, boxH);
        // Top face
        ctx2.fillStyle = 'rgba(255,255,255,0.15)';
        ctx2.fillRect(bx - boxW/2, by, boxW, 3);
        // Cross straps
        ctx2.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx2.lineWidth = 1;
        ctx2.beginPath();
        ctx2.moveTo(bx, by); ctx2.lineTo(bx, by + boxH);
        ctx2.moveTo(bx - boxW/2, by + boxH/2); ctx2.lineTo(bx + boxW/2, by + boxH/2);
        ctx2.stroke();
        // Border
        ctx2.globalAlpha = 0.5;
        ctx2.strokeStyle = 'rgba(255,255,255,0.4)';
        ctx2.lineWidth = 0.8;
        ctx2.strokeRect(bx - boxW/2, by, boxW, boxH);
    }
    ctx2.globalAlpha = 0.5 + 0.2 * Math.sin(t * 0.0015);
    ctx2.font = "7px 'Share Tech Mono'";
    ctx2.fillStyle = 'rgba(0,170,255,0.6)';
    ctx2.textAlign = 'center';
    ctx2.globalAlpha = 1;
    ctx2.fillText('CARGO', x, y + 10);
    ctx2.restore();
}

// =============================
// LAUNCH ANIMATION STATE
// =============================
let launchPhase = 'idle';
let launchTimer = 0;
let launchStartTime = 0;
let launchLastT = 0;

// Start screen animation loop
let startAnimId = null;
function startScreenLoop(t){
    if(launchPhase === 'done') return;

    // Update launch timer
    if(launchPhase !== 'idle'){
        const dt = launchLastT ? (t - launchLastT) : 16;
        launchTimer += dt;

        // Phase transitions
        if(launchPhase === 'walking' && launchTimer >= 1500){
            launchPhase = 'boarding'; launchTimer = 0;
        }
        else if(launchPhase === 'boarding' && launchTimer >= 500){
            launchPhase = 'powerup'; launchTimer = 0;
            // Fade the title out during powerup
            document.getElementById('start-title').style.transition = 'opacity 1.2s ease';
            document.getElementById('start-title').style.opacity = '0';
        }
        else if(launchPhase === 'powerup' && launchTimer >= 1500){
            launchPhase = 'warp'; launchTimer = 0;
            AudioManager.playWarp();
        }
        else if(launchPhase === 'warp' && launchTimer >= 800){
            launchPhase = 'done';
            finishLaunch();
            return;
        }
    }
    launchLastT = t;

    drawStartScreen(t);
    startAnimId = requestAnimationFrame(startScreenLoop);
}
// Kick off the start screen animation
requestAnimationFrame(startScreenLoop);

function startGame(){
    // Unlock audio context on user gesture
    AudioManager.onUserInteract();

    // Disable button
    const btn = document.getElementById('start-btn');
    btn.style.pointerEvents = 'none';
    btn.style.opacity = '0.3';

    // Fade out text elements
    document.getElementById('start-subtitle').style.transition = 'opacity 0.5s';
    document.getElementById('start-subtitle').style.opacity = '0';
    document.getElementById('start-intro').style.transition = 'opacity 0.5s';
    document.getElementById('start-intro').style.opacity = '0';
    document.getElementById('start-explainer').style.transition = 'opacity 0.5s';
    document.getElementById('start-explainer').style.opacity = '0';
    document.getElementById('start-version').style.transition = 'opacity 0.5s';
    document.getElementById('start-version').style.opacity = '0';
    btn.style.transition = 'opacity 0.5s';

    // Start animation sequence
    launchPhase = 'walking';
    launchTimer = 0;
}

function finishLaunch(){
    gameStarted = true;
    if(startAnimId) cancelAnimationFrame(startAnimId);

    // Fade out start screen
    const ss = document.getElementById('start-screen');
    ss.classList.add('hidden');
    setTimeout(() => { ss.style.display = 'none'; }, 900);

    // Show HUD and hints
    document.getElementById('hud').style.display = '';
    document.getElementById('zoom-hint').style.display = '';
    document.getElementById('tap-hint').classList.remove('hidden');
    document.getElementById('follow-btn').style.display = '';

    // Start the game loop
    AudioManager.startLoop();
    requestAnimationFrame(loop);
}


// =============================
// DEBUG LOG
// =============================
const MAX_LOG = 200;
let debugLines = [];
let debugCount = 0;
let debugCollapsed = false;
let debugHidden = true;      // starts hidden
let debugFilterIdle = false; // filter out 'skip' entries

function toggleDebug(){
    debugHidden = !debugHidden;
    document.getElementById("debug-panel").classList.toggle("hidden", debugHidden);
    document.getElementById("debug-toggle-btn").textContent = debugHidden ? "‚óà DEBUG" : "‚óà HIDE DEBUG";
}

function collapseDebug(){
    debugCollapsed = !debugCollapsed;
    document.getElementById("debug-panel").classList.toggle("collapsed", debugCollapsed);
}

function toggleFilter(){
    debugFilterIdle = !debugFilterIdle;
    document.getElementById("debug-filter-btn").classList.toggle("active", debugFilterIdle);
    renderDebug();
}

let overlayFilterIdle = true;

function showDebugOnDeath(){
    overlayFilterIdle = true;
    document.getElementById("debug-overlay-filter").classList.add("active");
    renderOverlay();
    document.getElementById("debug-overlay").classList.add("active");
}

function closeDebugOverlay(){
    document.getElementById("debug-overlay").classList.remove("active");
}

function toggleOverlayFilter(){
    overlayFilterIdle = !overlayFilterIdle;
    document.getElementById("debug-overlay-filter").classList.toggle("active", overlayFilterIdle);
    renderOverlay();
}

function renderOverlay(){
    const log = document.getElementById("debug-overlay-log");
    const lines = overlayFilterIdle
        ? debugLines.filter(l => l.type !== 'skip')
        : debugLines;
    document.getElementById("debug-overlay-count").textContent = `[${lines.length} entries]`;
    log.innerHTML = lines.map(l =>
        `<div class="dl ${l.type}">${l.msg}</div>`
    ).join("");
    log.scrollTop = log.scrollHeight;
}

// Start debug panel hidden
document.getElementById("debug-panel").classList.add("hidden");

function dbg(msg, type="info"){
    const now = (performance.now() / 1000).toFixed(1);
    debugLines.push({ msg:`[${now}s] ${msg}`, type });
    if(debugLines.length > MAX_LOG) debugLines.shift();
    debugCount++;
    renderDebug();
}

function renderDebug(){
    const log = document.getElementById("debug-log");
    document.getElementById("debug-count").textContent = `[${debugCount}]`;
    const lines = debugFilterIdle
        ? debugLines.filter(l => l.type !== 'skip')
        : debugLines;
    log.innerHTML = lines.map(l =>
        `<div class="dl ${l.type}">${l.msg}</div>`
    ).join("");
    log.scrollTop = log.scrollHeight;
}

// Throttle: only log chooseNext details every N ms to avoid spam
let lastChooseLog = 0;
const CHOOSE_LOG_INTERVAL = 2000;
let lastOxyWarn = 0;

// Show speed controls only in ?debug mode
if(new URLSearchParams(window.location.search).has('debug')){
    document.getElementById('speed-controls').classList.add('visible');
}

// =============================
// SPEED & MISSIONS
// =============================
let speedMultiplier = 1;
let missionsCompleted = 0;

function setSpeed(s){
    speedMultiplier = s;
    document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('spd' + s).classList.add('active');
}

// =============================
// NOTIFICATIONS
// =============================
const notifContainer = document.getElementById('notif-container');
function showNotif(text, color='#0af', extraClass=''){
    const el = document.createElement('div');
    el.className = 'notif' + (extraClass ? ' ' + extraClass : '');
    el.textContent = text;
    el.style.color = color;
    el.style.borderColor = color;
    el.style.textShadow = `0 0 12px ${color}`;
    notifContainer.appendChild(el);
    const dur = extraClass === 'event-major' ? 3300 : 2400;
    setTimeout(() => el.remove(), dur);
}

// =============================
// CAMERA
// =============================
const SOLAR_SCALE = 2.5; // multiplier applied to all orbit radii

// Danger radius = 60% of the innermost (Oxygen) orbit, so it always
// sits well inside that orbit regardless of screen size.
function sunDangerRadius(){
    return Math.min(canvas.width, canvas.height) / 2 * 0.22 * SOLAR_SCALE * 0.60;
}

function overviewZoom(){
    // Zoom level that fits the outermost orbit (factor 0.96) with a 10% margin
    const outerR = Math.min(canvas.width, canvas.height) / 2 * 0.96 * SOLAR_SCALE;
    return (Math.min(canvas.width, canvas.height) / 2 / outerR) * 0.88;
}

const FOLLOW_ZOOM = 3.0;

const camera = { 
    zoom: 1,
    targetZoom: 1,
    panX: 0, 
    panY: 0,
    follow: false
};


canvas.addEventListener("wheel", e => {
    e.preventDefault();
    if(camera.follow) return;
    const f = e.deltaY < 0 ? 1.12 : 0.89;
    const mx = e.clientX - canvas.width / 2;
    const my = e.clientY - canvas.height / 2;
    camera.panX = camera.panX * f + mx * (1 - f);
    camera.panY = camera.panY * f + my * (1 - f);
    const newZoom = Math.max(0.1, Math.min(14, camera.zoom * f));
    camera.zoom = newZoom;
    camera.targetZoom = newZoom;
}, { passive: false });

// =============================
// SCREEN ‚Üí WORLD COORDINATES
// =============================
function screenToWorld(sx, sy){
    return {
        x: (sx - canvas.width/2 - camera.panX) / camera.zoom + canvas.width/2,
        y: (sy - canvas.height/2 - camera.panY) / camera.zoom + canvas.height/2
    };
}

// Planet under a world coordinate (with tap padding)
function planetAt(wx, wy, padding=10){
    for(let p of planets){
        const pp = p.position();
        if(Math.hypot(wx - pp.x, wy - pp.y) <= p.size + padding)
            return p;
    }
    return null;
}

// Set the player-chosen target
let hoveredPlanet = null;

function setPlayerTarget(planet){
    if(!gameStarted) return;
    if(!ship.spawned) return;
    if(!planet) return;

    // Don't re-target the planet we're currently landed on/loading at
    if(planet === ship.landedPlanet) return;

    AudioManager.playConfirm();

    // Hide tap hint once player has used it
    const hint = document.getElementById('tap-hint');
    if(hint) hint.classList.add('hidden');

    const onWorld = ship.state === "landed" || ship.state === "eva" || ship.state === "loading";

    if(ship.state === "idle" || ship.state === "transfer"){
        ship.target = planet;
        ship.nextTarget = null;
        ship.state = "transfer";
        ship.departureTimer = 0;
        showNotif(`‚óà COURSE SET: ${planet.name.toUpperCase()}`, '#0af');
        dbg(`‚ñ∂ PLAYER: GO TO ${planet.name.toUpperCase()}`, 'good');
    } else if(onWorld || ship.state === "takeoff"){
        // Always allow queueing while Jed is on-world or during takeoff
        ship.nextTarget = planet;
        const label = onWorld ? 'NEXT' : 'QUEUED';
        showNotif(`‚óà ${label}: ${planet.name.toUpperCase()}`, '#6af');
        dbg(`‚ñ∂ PLAYER: QUEUE ${planet.name.toUpperCase()} (state=${ship.state})`, 'good');
    } else {
        ship.nextTarget = planet;
        showNotif(`‚óà QUEUED: ${planet.name.toUpperCase()}`, '#6af');
        dbg(`‚ñ∂ PLAYER: QUEUE ${planet.name.toUpperCase()} (state=${ship.state})`, 'good');
    }

    // Update planet nav highlight
    updatePlanetNavHighlight();
}

let dragging = false, dragStart = {x:0,y:0}, panStart = {x:0,y:0};
let dragMoved = false;

canvas.addEventListener("mousedown", e => {
    if(!gameStarted) return;
    dragging = true;
    dragMoved = false;
    dragStart = { x: e.clientX, y: e.clientY };
    panStart  = { x: camera.panX, y: camera.panY };
});
canvas.addEventListener("mousemove", e => {
    if(!gameStarted) return;
    if(dragging && !camera.follow){
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;
        if(Math.hypot(dx, dy) > 4) dragMoved = true;
        camera.panX = panStart.x + dx;
        camera.panY = panStart.y + dy;
    }
    // Hover detection
    const w = screenToWorld(e.clientX, e.clientY);
    const hp = planetAt(w.x, w.y, 14);
    if(hp !== hoveredPlanet){
        hoveredPlanet = hp;
        canvas.style.cursor = hp ? 'pointer' : 'crosshair';
    }
});
window.addEventListener("mouseup", e => {
    if(!gameStarted) return;
    if(dragging && !dragMoved){
        // Click ‚Äî check planet
        const w = screenToWorld(e.clientX, e.clientY);
        const p = planetAt(w.x, w.y, 14);
        if(p) setPlayerTarget(p);
    }
    dragging = false;
});

// =============================
// TOUCH EVENTS (mobile)
// =============================
let touches = {};
let lastPinchDist = null;
let touchPanStart = null;

function getTouchDist(t1, t2){
    return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
}
function getTouchMid(t1, t2){
    return { x:(t1.clientX+t2.clientX)/2, y:(t1.clientY+t2.clientY)/2 };
}

canvas.addEventListener("touchstart", e => {
    if(!gameStarted) return;
    e.preventDefault();
    if(e.touches.length === 1){
        // single finger pan
        lastPinchDist = null;
        touchPanStart = {
            tx: e.touches[0].clientX,
            ty: e.touches[0].clientY,
            px: camera.panX,
            py: camera.panY,
            moved: false
        };
    } else if(e.touches.length === 2){
        // two finger pinch
        lastPinchDist = getTouchDist(e.touches[0], e.touches[1]);
        touchPanStart = null;
    }
}, { passive: false });

canvas.addEventListener("touchmove", e => {
    if(!gameStarted) return;
    e.preventDefault();
    if(camera.follow) return;
    if(e.touches.length === 1 && touchPanStart){
        // pan
        const dx = e.touches[0].clientX - touchPanStart.tx;
        const dy = e.touches[0].clientY - touchPanStart.ty;
        if(Math.hypot(dx, dy) > 8) touchPanStart.moved = true;
        camera.panX = touchPanStart.px + dx;
        camera.panY = touchPanStart.py + dy;
    } else if(e.touches.length === 2 && lastPinchDist !== null){
        // pinch zoom
        const dist = getTouchDist(e.touches[0], e.touches[1]);
        const f = dist / lastPinchDist;
        lastPinchDist = dist;
        const mid = getTouchMid(e.touches[0], e.touches[1]);
        const mx = mid.x - canvas.width / 2;
        const my = mid.y - canvas.height / 2;
        camera.panX = camera.panX * f + mx * (1 - f);
        camera.panY = camera.panY * f + my * (1 - f);
        const newZoom = Math.max(0.1, Math.min(14, camera.zoom * f));
        camera.zoom = newZoom;
        camera.targetZoom = newZoom;
    }
}, { passive: false });

canvas.addEventListener("touchend", e => {
    if(!gameStarted) return;
    e.preventDefault();
    // Tap detection ‚Äî single touch lifted without significant movement
    if(e.changedTouches.length === 1 && touchPanStart && !touchPanStart.moved){
        const t = e.changedTouches[0];
        const w = screenToWorld(t.clientX, t.clientY);
        const p = planetAt(w.x, w.y, 18);  // slightly bigger touch target
        if(p) setPlayerTarget(p);
    }
    if(e.touches.length < 2) lastPinchDist = null;
    if(e.touches.length === 0) touchPanStart = null;
}, { passive: false });

function applyCamera(){
    ctx.translate(canvas.width/2 + camera.panX, canvas.height/2 + camera.panY);
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-canvas.width/2, -canvas.height/2);
}
const followBtn = document.getElementById("follow-btn");

followBtn.addEventListener("click", () => {
    camera.follow = !camera.follow;

    followBtn.textContent = "CAM: " + (camera.follow ? "ON" : "OFF");
    followBtn.classList.toggle("active", camera.follow);

    // Animate planet nav in/out
    const pNav = document.getElementById('planet-nav');
    if(camera.follow){
        pNav.style.display = 'flex';
        // Slight delay so display:flex is applied before transition fires
        requestAnimationFrame(() => requestAnimationFrame(() => {
            pNav.classList.add('visible');
        }));
        camera.targetZoom = FOLLOW_ZOOM;
    } else {
        pNav.classList.remove('visible');
        // Hide after transition completes
        setTimeout(() => { if(!camera.follow) pNav.style.display = 'none'; }, 350);
        camera.targetZoom = overviewZoom();
        camera.panX = 0;
        camera.panY = 0;
    }
});


// =============================
// RESIZE + STARS
// =============================
let stars = [];
let nebulaPoints = [];
function buildStars(){
    stars = [];
    // Colored star types: blue giants, red dwarfs, warm yellows, standard white
    const starColors = [
        {r:180, g:210, b:255, freq:0.15}, // blue-white giants
        {r:255, g:200, b:160, freq:0.1},  // warm yellow-orange
        {r:255, g:160, b:130, freq:0.06}, // red dwarfs
        {r:200, g:220, b:255, freq:0.12}, // cool blue
        {r:255, g:255, b:255, freq:0.57}, // standard white
    ];
    for(let i = 0; i < 650; i++){
        let roll = Math.random();
        let col = starColors[starColors.length-1];
        let acc = 0;
        for(let c of starColors){ acc += c.freq; if(roll < acc){ col = c; break; } }
        const bright = Math.random() > 0.97; // rare bright stars
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            r: bright ? Math.random() * 2.2 + 1.2 : Math.random() * 1.2 + 0.2,
            a: Math.random() * 0.6 + 0.3,
            tw: Math.random() * 3 + 1,
            cr: col.r, cg: col.g, cb: col.b,
            bright
        });
    }
    // Nebula points (static colorful cloud blobs)
    nebulaPoints = [];
    const nebColors = [
        [20,40,100], [40,0,80], [0,60,80], [80,20,20], [0,80,60]
    ];
    for(let i = 0; i < 8; i++){
        const nc = nebColors[i % nebColors.length];
        nebulaPoints.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            r: 80 + Math.random() * 200,
            cr: nc[0], cg: nc[1], cb: nc[2],
            a: 0.04 + Math.random() * 0.06
        });
    }
}
function drawNebula(){
    for(let n of nebulaPoints){
        const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r);
        g.addColorStop(0, `rgba(${n.cr},${n.cg},${n.cb},${n.a})`);
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);
        ctx.fill();
    }
}
function resize(){
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
    buildStars();
    // Reset to overview zoom whenever window resizes
    if(!camera.follow){
        camera.zoom = overviewZoom();
        camera.targetZoom = camera.zoom;
    }
    // Resize start canvas for DPI
    const sc = document.getElementById('start-canvas');
    if(sc){
        const rect = sc.getBoundingClientRect();
        sc.width = rect.width * (window.devicePixelRatio || 1);
        sc.height = rect.height * (window.devicePixelRatio || 1);
        sctx.setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);
    }
}
window.addEventListener("resize", resize);
resize();
// Set initial overview zoom after first resize
camera.zoom = overviewZoom();
camera.targetZoom = camera.zoom;

function center(){ return { x: canvas.width/2, y: canvas.height/2 }; }

function randRange(min, max){
    return Math.floor(Math.random() * (max - min + 1)) + min;
}


function drawStars(t){
    for(let s of stars){
        const twinkle = 0.6 + 0.4 * Math.sin(t / 1000 * s.tw);
        ctx.globalAlpha = s.a * twinkle;
        ctx.fillStyle = `rgb(${s.cr},${s.cg},${s.cb})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill();
        // Draw cross sparkle on rare bright stars
        if(s.bright){
            const len = s.r * 3.5 * twinkle;
            ctx.globalAlpha = s.a * twinkle * 0.5;
            ctx.strokeStyle = `rgb(${s.cr},${s.cg},${s.cb})`;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(s.x - len, s.y); ctx.lineTo(s.x + len, s.y);
            ctx.moveTo(s.x, s.y - len); ctx.lineTo(s.x, s.y + len);
            ctx.stroke();
        }
    }
    ctx.globalAlpha = 1;
}

// =============================
// COLOR UTILS
// =============================
function shiftColor(hex, amt){
    let r, g, b;
    const m = hex.match(/^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
    if(m){ r=parseInt(m[1],16); g=parseInt(m[2],16); b=parseInt(m[3],16); }
    else {
        const tmp=document.createElement('canvas'); tmp.width=tmp.height=1;
        const tc=tmp.getContext('2d'); tc.fillStyle=hex; tc.fillRect(0,0,1,1);
        const d=tc.getImageData(0,0,1,1).data; r=d[0];g=d[1];b=d[2];
    }
    r=Math.min(255,Math.max(0,Math.round(r+amt*255)));
    g=Math.min(255,Math.max(0,Math.round(g+amt*255)));
    b=Math.min(255,Math.max(0,Math.round(b+amt*255)));
    return `rgb(${r},${g},${b})`;
}
const lighten = (h, a) => shiftColor(h,  a);
const darken  = (h, a) => shiftColor(h, -a);

// =============================
// SUN
// =============================
function drawSun(t){
    const c = center();
    const pulse = 1 + 0.02 * Math.sin(t / 600);

    // Danger zone ring ‚Äî pulsing red warning
    const dangerRadius = sunDangerRadius();
    const dangerPulse = 0.3 + 0.15 * Math.sin(t / 400);
    ctx.beginPath();
    ctx.arc(c.x, c.y, dangerRadius, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255,60,20,${dangerPulse})`;
    ctx.lineWidth = 1.5 / camera.zoom;
    ctx.setLineDash([4 / camera.zoom, 6 / camera.zoom]);
    ctx.stroke();
    ctx.setLineDash([]);

    for(let i = 3; i > 0; i--){
        const grad = ctx.createRadialGradient(c.x, c.y, 24, c.x, c.y, 40*i*pulse);
        grad.addColorStop(0, 'rgba(255,200,50,0.15)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(c.x, c.y, 40*i*pulse, 0, Math.PI*2);
        ctx.fill();
    }

    const sunGrad = ctx.createRadialGradient(c.x-8, c.y-8, 4, c.x, c.y, 28*pulse);
    sunGrad.addColorStop(0, '#fff8c0');
    sunGrad.addColorStop(0.4, '#ffcc00');
    sunGrad.addColorStop(1, '#ff6600');
    ctx.fillStyle = sunGrad;
    ctx.beginPath();
    ctx.arc(c.x, c.y, 28*pulse, 0, Math.PI*2);
    ctx.fill();
}

// =============================
// PLANETS
// =============================
function hexToRgba(hex, a){
    const m = hex.match(/^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
    return m ? `rgba(${parseInt(m[1],16)},${parseInt(m[2],16)},${parseInt(m[3],16)},${a})` : hex;
}

class Planet {
    constructor(name, orbitFactor, size, color, resource, glowColor){
        this.name = name;
        this.orbitFactor = orbitFactor;
        this.size = size;
        this.color = color;
        this.glowColor = glowColor || color;
        this.glowRGBA = hexToRgba(this.glowColor, 0.2);
        this.resource = resource;
        this.angle = 0; // overwritten after array is built
        const speedTable = {
        "Oxygen": 0.00026,   // fast inner orbit ‚Äî zips around
        "Food":   0.00008,   // leisurely mid-orbit
        "Water":  0.000052,  // slightly slower still
        "Fuel":   0.000019,  // slow gas giant
        "Repair": 0.000007,  // glacially slow outermost planet
    };
    this.speed = speedTable[name] ?? (0.00005 + Math.random() * 0.00003);
    this._texCanvas = null;
    this._buildTex();
    }

    // ‚îÄ‚îÄ Seeded RNG shared by all texture helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    _rngForName() {
        let h = 5381;
        for (let i = 0; i < this.name.length; i++)
            h = (((h << 5) + h) + this.name.charCodeAt(i)) | 0;
        return () => { h ^= h << 13; h ^= h >> 17; h ^= h << 5; return (h >>> 0) / 0x100000000; };
    }

    _buildTex() {
        const SZ = 256;
        const oc = document.createElement('canvas');
        oc.width = oc.height = SZ;
        const o = oc.getContext('2d');
        const rnd = this._rngForName();
        const c = SZ / 2;

        // clip everything to planet disc
        o.beginPath(); o.arc(c, c, c - 1, 0, Math.PI * 2); o.clip();

        if      (this.resource === 'oxygen') this._texOxygen(o, SZ, c, rnd);
        else if (this.resource === 'food')   this._texFood(o, SZ, c, rnd);
        else if (this.resource === 'water')  this._texWater(o, SZ, c, rnd);
        else if (this.resource === 'fuel')   this._texFuel(o, SZ, c, rnd);
        else if (this.resource === 'repair') this._texRepair(o, SZ, c, rnd);

        this._texCanvas = oc;
        this._texSZ = SZ;
    }

    _texOxygen(o, SZ, c, rnd) {
        // Ice-blue base gradient
        const bg = o.createRadialGradient(c * 0.75, c * 0.7, 0, c, c, c * 1.1);
        bg.addColorStop(0, '#dff0ff'); bg.addColorStop(0.6, '#a8ccf0'); bg.addColorStop(1, '#5888cc');
        o.fillStyle = bg; o.fillRect(0, 0, SZ, SZ);

        // Ice sheet variation ‚Äî overlapping bright/dark patches
        for (let i = 0; i < 14; i++) {
            const px = rnd() * SZ, py = rnd() * SZ, r = SZ * (0.06 + rnd() * 0.2);
            const bright = rnd() > 0.45;
            const g = o.createRadialGradient(px, py, 0, px, py, r);
            g.addColorStop(0, bright ? 'rgba(255,255,255,0.65)' : 'rgba(100,155,215,0.5)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            o.fillStyle = g; o.beginPath(); o.arc(px, py, r, 0, Math.PI * 2); o.fill();
        }

        // Crack network (fault lines through ice)
        o.strokeStyle = '#3a78cc'; o.lineCap = 'round';
        let cx = rnd() * SZ, cy = rnd() * SZ;
        for (let i = 0; i < 28; i++) {
            const nx = cx + (rnd() - 0.5) * SZ * 0.38, ny = cy + (rnd() - 0.5) * SZ * 0.38;
            o.globalAlpha = 0.25 + rnd() * 0.45;
            o.lineWidth = 0.8 + rnd() * 1.8;
            o.beginPath(); o.moveTo(cx, cy); o.lineTo(nx, ny); o.stroke();
            if (rnd() > 0.38) { cx = nx; cy = ny; } else { cx = rnd() * SZ; cy = rnd() * SZ; }
        }

        // North polar cap
        const nc = o.createRadialGradient(c, -SZ * 0.06, 0, c, -SZ * 0.06, SZ * 0.58);
        nc.addColorStop(0, 'rgba(255,255,255,1)'); nc.addColorStop(0.5, 'rgba(240,250,255,0.88)');
        nc.addColorStop(0.78, 'rgba(215,238,255,0.4)'); nc.addColorStop(1, 'rgba(0,0,0,0)');
        o.globalAlpha = 1; o.fillStyle = nc; o.beginPath(); o.arc(c, -SZ*0.06, SZ*0.58, 0, Math.PI*2); o.fill();

        // South polar cap (smaller)
        const sc = o.createRadialGradient(c, SZ * 1.06, 0, c, SZ * 1.06, SZ * 0.42);
        sc.addColorStop(0, 'rgba(255,255,255,0.95)'); sc.addColorStop(0.55, 'rgba(225,245,255,0.6)');
        sc.addColorStop(1, 'rgba(0,0,0,0)');
        o.fillStyle = sc; o.beginPath(); o.arc(c, SZ*1.06, SZ*0.42, 0, Math.PI*2); o.fill();
        o.globalAlpha = 1;
    }

    _texFood(o, SZ, c, rnd) {
        // Ocean base
        const bg = o.createRadialGradient(c*0.78, c*0.72, 0, c, c, c * 1.1);
        bg.addColorStop(0, '#2470a8'); bg.addColorStop(1, '#0c2a58');
        o.fillStyle = bg; o.fillRect(0, 0, SZ, SZ);

        // Continents ‚Äî overlapping organic blobs (dark + mid + light green layers)
        const greens = ['#1e5228','#2d7038','#3d8e4a','#50a860','#6abf70'];
        for (let i = 0; i < 18; i++) {
            const px = rnd() * SZ, py = rnd() * SZ, r = SZ * (0.09 + rnd() * 0.24);
            const col = greens[Math.floor(rnd() * greens.length)];
            const g = o.createRadialGradient(px * 0.92, py * 0.92, 0, px, py, r);
            g.addColorStop(0, col); g.addColorStop(0.72, col); g.addColorStop(1, 'rgba(0,0,0,0)');
            o.globalAlpha = 0.82; o.fillStyle = g;
            o.beginPath(); o.arc(px, py, r, 0, Math.PI * 2); o.fill();
        }

        // Desert / highland accent (warm tan on some continents)
        for (let i = 0; i < 5; i++) {
            const px = rnd() * SZ, py = rnd() * SZ, r = SZ * (0.04 + rnd() * 0.09);
            const g = o.createRadialGradient(px, py, 0, px, py, r);
            g.addColorStop(0, 'rgba(195,158,80,0.7)'); g.addColorStop(1, 'rgba(0,0,0,0)');
            o.globalAlpha = 0.6; o.fillStyle = g;
            o.beginPath(); o.arc(px, py, r, 0, Math.PI * 2); o.fill();
        }

        // Cloud wisps
        for (let i = 0; i < 12; i++) {
            const px = rnd() * SZ, py = rnd() * SZ;
            const rx = SZ * (0.06 + rnd() * 0.22), ry = SZ * (0.025 + rnd() * 0.065);
            const angle = rnd() * Math.PI;
            o.globalAlpha = 0.22 + rnd() * 0.28; o.fillStyle = 'rgba(245,250,255,1)';
            o.beginPath(); o.ellipse(px, py, rx, ry, angle, 0, Math.PI * 2); o.fill();
        }
        o.globalAlpha = 1;
    }

    _texWater(o, SZ, c, rnd) {
        // Deep ocean base
        const bg = o.createRadialGradient(c*0.8, c*0.75, 0, c, c, c * 1.1);
        bg.addColorStop(0, '#1a4898'); bg.addColorStop(1, '#040e2c');
        o.fillStyle = bg; o.fillRect(0, 0, SZ, SZ);

        // Deep trenches and current swirls
        for (let i = 0; i < 14; i++) {
            const px = rnd() * SZ, py = rnd() * SZ;
            const rx = SZ * (0.07 + rnd() * 0.26), ry = SZ * (0.025 + rnd() * 0.12);
            const angle = rnd() * Math.PI;
            const dark = rnd() > 0.45;
            const g = o.createRadialGradient(px, py, 0, px, py, Math.max(rx, ry));
            g.addColorStop(0, dark ? 'rgba(4,14,44,0.7)' : 'rgba(50,120,220,0.55)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            o.globalAlpha = 0.7; o.fillStyle = g;
            o.beginPath(); o.ellipse(px, py, rx, ry, angle, 0, Math.PI*2); o.fill();
        }

        // Polar ice caps
        const nc = o.createRadialGradient(c, -SZ*0.08, 0, c, -SZ*0.08, SZ*0.55);
        nc.addColorStop(0, 'rgba(235,248,255,0.98)'); nc.addColorStop(0.48, 'rgba(210,238,255,0.72)');
        nc.addColorStop(0.75, 'rgba(185,225,255,0.18)'); nc.addColorStop(1, 'rgba(0,0,0,0)');
        o.globalAlpha = 1; o.fillStyle = nc; o.beginPath(); o.arc(c, -SZ*0.08, SZ*0.55, 0, Math.PI*2); o.fill();

        const sc = o.createRadialGradient(c, SZ*1.08, 0, c, SZ*1.08, SZ*0.44);
        sc.addColorStop(0, 'rgba(235,248,255,0.92)'); sc.addColorStop(0.55, 'rgba(205,235,255,0.55)');
        sc.addColorStop(1, 'rgba(0,0,0,0)');
        o.fillStyle = sc; o.beginPath(); o.arc(c, SZ*1.08, SZ*0.44, 0, Math.PI*2); o.fill();
        o.globalAlpha = 1;
    }

    _texFuel(o, SZ, c, rnd) {
        // Jupiter-style gas giant with horizontal turbulent bands
        const bands = [
            '#e8c070','#d08848','#be6e2e','#dca050',
            '#f0d898','#b86828','#e09858','#c87838'
        ];
        // Phase offsets per frequency to vary the turbulence per planet
        const phases = [rnd()*6.28, rnd()*6.28, rnd()*6.28, rnd()*6.28];

        // Draw band-by-band, one pixel row at a time for the wavy effect
        const imgData = o.getImageData(0, 0, SZ, SZ);
        const d = imgData.data;
        for (let y = 0; y < SZ; y++) {
            let t = y / SZ;
            // Multi-frequency turbulence (different scales of waviness)
            const noise = Math.sin(t * 20   + phases[0]) * 0.028
                        + Math.sin(t * 8.5  + phases[1]) * 0.048
                        + Math.sin(t * 38   + phases[2]) * 0.012
                        + Math.sin(t * 55   + phases[3]) * 0.006;
            t = ((t + noise) % 1 + 1) % 1;
            const bi = Math.floor(t * bands.length) % bands.length;
            // Parse band hex to RGB
            const m = bands[bi].match(/[\da-f]{2}/gi);
            const br = parseInt(m[0],16), bg2 = parseInt(m[1],16), bb = parseInt(m[2],16);
            for (let x = 0; x < SZ; x++) {
                const idx = (y * SZ + x) * 4;
                d[idx] = br; d[idx+1] = bg2; d[idx+2] = bb; d[idx+3] = 255;
            }
        }
        o.putImageData(imgData, 0, 0);

        // Great storm oval (Red Spot equivalent)
        const sx = c * (0.55 + rnd() * 0.9), sy = SZ * (0.38 + rnd() * 0.24);
        const stG = o.createRadialGradient(sx*0.96, sy*0.96, 0, sx, sy, SZ*0.14);
        stG.addColorStop(0, 'rgba(240,210,140,0.95)');
        stG.addColorStop(0.42, 'rgba(218,128,48,0.75)');
        stG.addColorStop(1, 'rgba(180,70,15,0)');
        o.fillStyle = stG;
        o.beginPath(); o.ellipse(sx, sy, SZ*0.155, SZ*0.072, 0, 0, Math.PI*2); o.fill();

        // Smaller storm ovals
        for (let i = 0; i < 3; i++) {
            const ssX = rnd() * SZ, ssY = rnd() * SZ;
            const ssG = o.createRadialGradient(ssX, ssY, 0, ssX, ssY, SZ*0.055);
            ssG.addColorStop(0, 'rgba(255,220,140,0.7)'); ssG.addColorStop(1, 'rgba(0,0,0,0)');
            o.globalAlpha = 0.55; o.fillStyle = ssG;
            o.beginPath(); o.ellipse(ssX, ssY, SZ*0.065, SZ*0.028, 0, 0, Math.PI*2); o.fill();
        }
        o.globalAlpha = 1;
    }

    _texRepair(o, SZ, c, rnd) {
        // Rocky/barren moon-like surface with purple-grey tones
        const bg = o.createRadialGradient(c*0.75, c*0.7, 0, c, c, c * 1.1);
        bg.addColorStop(0, '#9e8eb8'); bg.addColorStop(0.65, '#7a6890'); bg.addColorStop(1, '#3e2e55');
        o.fillStyle = bg; o.fillRect(0, 0, SZ, SZ);

        // Surface terrain variation ‚Äî highland and lowland patches
        for (let i = 0; i < 16; i++) {
            const px = rnd() * SZ, py = rnd() * SZ, r = SZ * (0.05 + rnd() * 0.2);
            const hl = rnd() > 0.5;
            const g = o.createRadialGradient(px, py, 0, px, py, r);
            g.addColorStop(0, hl ? 'rgba(175,162,200,0.55)' : 'rgba(42,30,62,0.6)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            o.fillStyle = g; o.beginPath(); o.arc(px, py, r, 0, Math.PI*2); o.fill();
        }

        // Craters with ejecta blanket + bowl shadow + rim highlight
        for (let i = 0; i < 14; i++) {
            const px = SZ * (0.08 + rnd() * 0.84), py = SZ * (0.08 + rnd() * 0.84);
            const r = SZ * (0.025 + rnd() * 0.09);

            // Ejecta (lighter halo outside crater)
            const ej = o.createRadialGradient(px, py, r * 0.7, px, py, r * 2.0);
            ej.addColorStop(0, 'rgba(185,172,210,0.38)'); ej.addColorStop(1, 'rgba(0,0,0,0)');
            o.fillStyle = ej; o.beginPath(); o.arc(px, py, r * 2.0, 0, Math.PI*2); o.fill();

            // Bowl (dark gradient, offset for 3-D shadow from upper-left light)
            const bowl = o.createRadialGradient(px*0.97, py*0.97, 0, px, py, r);
            bowl.addColorStop(0, 'rgba(25,15,42,0.9)');
            bowl.addColorStop(0.6, 'rgba(40,28,58,0.65)');
            bowl.addColorStop(1, 'rgba(0,0,0,0)');
            o.fillStyle = bowl; o.beginPath(); o.arc(px, py, r, 0, Math.PI*2); o.fill();

            // Rim highlight (south/right arc only ‚Äî facing light)
            o.strokeStyle = 'rgba(215,202,235,0.55)';
            o.lineWidth = Math.max(0.6, r * 0.14);
            o.beginPath(); o.arc(px, py, r * 0.88, Math.PI * 0.15, Math.PI * 0.85); o.stroke();
        }

        // Impact scars / fault lines
        o.lineCap = 'round'; o.strokeStyle = 'rgba(35,22,52,0.55)';
        for (let i = 0; i < 4; i++) {
            o.lineWidth = 1 + rnd() * 2.5; o.globalAlpha = 0.45 + rnd() * 0.3;
            o.beginPath();
            o.moveTo(rnd() * SZ, rnd() * SZ); o.lineTo(rnd() * SZ, rnd() * SZ);
            o.stroke();
        }
        o.globalAlpha = 1;
    }

    drawTexture(px, py, t) {
        if (!this._texCanvas) return;
        ctx.save();
        // Clip strictly to planet disc
        ctx.beginPath(); ctx.arc(px, py, this.size - 0.5, 0, Math.PI * 2); ctx.clip();
        ctx.translate(px, py);
        // Slow surface rotation ‚Äî different rate per type
        const rotRates = { oxygen:0.28, food:0.16, water:0.20, fuel:0.07, repair:0.10 };
        ctx.rotate(this.angle * (rotRates[this.resource] || 0.12));
        const s = (this.size * 2) / this._texSZ;
        ctx.scale(s, s);
        ctx.drawImage(this._texCanvas, -this._texSZ / 2, -this._texSZ / 2);
        ctx.restore();
    }

    orbitRadius(){
        return Math.min(canvas.width, canvas.height) / 2 * this.orbitFactor * SOLAR_SCALE;
    }

    update(dt){ this.angle += this.speed * dt; }

    position(){
        const c = center();
        const r = this.orbitRadius();
        return { x: c.x + Math.cos(this.angle)*r, y: c.y + Math.sin(this.angle)*r };
    }

    draw(t){
        const p  = this.position();
        const c  = center();
        const r  = this.orbitRadius();

        // Orbit ring
        ctx.beginPath();
        ctx.arc(c.x, c.y, r, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,255,255,0.04)";
        ctx.lineWidth = 1 / camera.zoom;
        ctx.stroke();

        // Atmosphere glow
        const pulse = 1 + 0.04 * Math.sin(t / 800);
        const grad = ctx.createRadialGradient(p.x, p.y, this.size*0.5, p.x, p.y, this.size*3*pulse);
        grad.addColorStop(0, this.glowRGBA);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.beginPath();
        ctx.arc(p.x, p.y, this.size*3*pulse, 0, Math.PI*2);
        ctx.fillStyle = grad;
        ctx.fill();

        // Planet body base gradient
        const bg = ctx.createRadialGradient(p.x - this.size*0.3, p.y - this.size*0.3, this.size*0.1, p.x, p.y, this.size);
        bg.addColorStop(0, lighten(this.color, 0.4));
        bg.addColorStop(1, darken(this.color, 0.4));
        ctx.fillStyle = bg;
        ctx.beginPath(); ctx.arc(p.x, p.y, this.size, 0, Math.PI*2); ctx.fill();

        // Surface texture (rendered to offscreen canvas, drawImage'd in)
        this.drawTexture(p.x, p.y, t);

        // Specular highlight ‚Äî gives the sphere its round feel
        const spec = ctx.createRadialGradient(
            p.x - this.size * 0.34, p.y - this.size * 0.34, 0,
            p.x, p.y, this.size
        );
        spec.addColorStop(0,    'rgba(255,255,255,0.20)');
        spec.addColorStop(0.35, 'rgba(255,255,255,0.05)');
        spec.addColorStop(1,    'rgba(0,0,0,0)');
        ctx.fillStyle = spec;
        ctx.beginPath(); ctx.arc(p.x, p.y, this.size, 0, Math.PI*2); ctx.fill();

        // Limb darkening ‚Äî edges go dark to reinforce sphere depth
        const limb = ctx.createRadialGradient(p.x, p.y, this.size * 0.55, p.x, p.y, this.size);
        limb.addColorStop(0, 'rgba(0,0,0,0)');
        limb.addColorStop(1, 'rgba(0,0,0,0.42)');
        ctx.fillStyle = limb;
        ctx.beginPath(); ctx.arc(p.x, p.y, this.size, 0, Math.PI*2); ctx.fill();

        // Planet rings (for outer resource planets)
        if(this.resource === "fuel" || this.resource === "repair"){
            const ringColor = this.resource === "fuel" ? 'rgba(200,140,40,' : 'rgba(140,60,220,';
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.scale(1, 0.28);
            // Outer ring
            ctx.beginPath();
            ctx.arc(0, 0, this.size * 2.2, 0, Math.PI*2);
            ctx.strokeStyle = ringColor + '0.35)';
            ctx.lineWidth = this.size * 0.55 / 0.28;
            ctx.stroke();
            // Inner ring gap / detail
            ctx.beginPath();
            ctx.arc(0, 0, this.size * 1.65, 0, Math.PI*2);
            ctx.strokeStyle = ringColor + '0.15)';
            ctx.lineWidth = this.size * 0.25 / 0.28;
            ctx.stroke();
            ctx.restore();
        }

        // Label
        ctx.save();
        ctx.font = `${9 / camera.zoom}px 'Share Tech Mono'`;
        ctx.fillStyle = "rgba(255,255,255,0.55)";
        ctx.textAlign = "center";
        ctx.fillText(this.name.toUpperCase(), p.x, p.y + this.size + 14 / camera.zoom);
        ctx.restore();

        // ‚îÄ‚îÄ Targeting indicator ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const isTarget  = (ship.target === this || ship.nextTarget === this);
        const isHovered = (hoveredPlanet === this);
        const isLanded  = (ship.landedPlanet === this);

        if(isTarget || isHovered){
            const ringR = this.size + 7;
            const resColors2 = { oxygen:'#00bbff', water:'#4488ff', food:'#44dd77', fuel:'#ffaa00', repair:'#cc44ff' };
            const rc = resColors2[this.resource] || '#0af';
            const alpha = isTarget ? (0.5 + 0.35 * Math.sin(t / 300)) : 0.3;

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = rc;
            ctx.lineWidth = (isTarget ? 1.5 : 1) / camera.zoom;
            ctx.shadowColor = rc;
            ctx.shadowBlur = isTarget ? 10 : 4;

            if(isTarget){
                // Spinning dashed target ring
                ctx.setLineDash([4 / camera.zoom, 4 / camera.zoom]);
                ctx.lineDashOffset = -(t / 80) % (8 / camera.zoom);
            }
            ctx.beginPath();
            ctx.arc(p.x, p.y, ringR, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.shadowBlur = 0;

            // Tick mark reticle ‚Äî 8 short radial lines around the ring
            if(isTarget){
                ctx.globalAlpha = alpha * 0.85;
                ctx.lineWidth = 1.5 / camera.zoom;
                const tickCount = 8;
                const innerR = ringR + 3;
                const outerR = ringR + 9;
                const rot = t / 2400;  // slow rotation
                for(let qi = 0; qi < tickCount; qi++){
                    const qa = (qi / tickCount) * Math.PI * 2 + rot;
                    ctx.beginPath();
                    ctx.moveTo(p.x + Math.cos(qa) * innerR, p.y + Math.sin(qa) * innerR);
                    ctx.lineTo(p.x + Math.cos(qa) * outerR, p.y + Math.sin(qa) * outerR);
                    ctx.stroke();
                }
            }
            ctx.restore();
        }

        // Landed indicator (solid ring)
        if(isLanded){
            ctx.save();
            ctx.globalAlpha = 0.35;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1 / camera.zoom;
            ctx.beginPath();
            ctx.arc(p.x, p.y, this.size + 4, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    }  // end draw()
}

const planets = [
    new Planet("Oxygen", 0.22, 13, "#00aaff", "oxygen", "#00aaff"),
    new Planet("Food",   0.40, 22, "#44cc66", "food",   "#44cc66"),
    new Planet("Water",  0.58, 14, "#2255dd", "water",  "#2255dd"),
    new Planet("Fuel",   0.76, 26, "#dd8800", "fuel",   "#dd8800"),
    new Planet("Repair", 0.96, 17, "#aa44ff", "repair", "#aa44ff"),
];

// Spread planets evenly around the system so they never clump on init.
// A random global offset rotates the whole formation each game, and a
// small per-planet jitter (¬±18¬∞) keeps it from looking too mechanical.
(function spreadPlanets(){
    const n = planets.length;
    const globalOffset = Math.random() * Math.PI * 2;
    const jitterRange  = Math.PI / 10; // ¬±18¬∞
    for(let i = 0; i < n; i++){
        const base   = (i / n) * Math.PI * 2 + globalOffset;
        const jitter = (Math.random() - 0.5) * 2 * jitterRange;
        planets[i].angle = base + jitter;
    }
})();

// Build planet nav buttons
const _navBtnMap = new Map(); // planet ‚Üí button element

(function buildPlanetNav(){
    const pColors = { oxygen:'#00bbff', water:'#4488ff', food:'#44dd77', fuel:'#ffaa00', repair:'#cc44ff' };
    const nav = document.getElementById('planet-nav');
    for(const p of planets){
        const btn = document.createElement('button');
        btn.className = 'planet-nav-btn';
        btn.textContent = p.name.toUpperCase();
        const col = pColors[p.resource] || '#0af';
        btn.style.color = col;
        btn.style.borderColor = col + '44';
        _navBtnMap.set(p, btn);

        let _touchActive = false;
        btn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            _touchActive = true;
        }, { passive: true });
        btn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if(_touchActive){ _touchActive = false; setPlayerTarget(p); }
        }, { passive: false });
        btn.addEventListener('touchcancel', () => { _touchActive = false; });
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            setPlayerTarget(p);
        });
        nav.appendChild(btn);
    }
})();

function updatePlanetNavHighlight(){
    for(const [p, btn] of _navBtnMap){
        const isTarget  = ship && (ship.target === p || ship.nextTarget === p);
        btn.classList.toggle('active-target', isTarget);
    }
}

// =============================
// THRUST TRAIL
// =============================
class Trail {
    constructor(){ this.particles = []; }

    emit(x, y, vx, vy, color){
        for(let i = 0; i < 3; i++){
            this.particles.push({
                x, y,
                vx: vx * -0.08 + (Math.random()-0.5) * 0.8,
                vy: vy * -0.08 + (Math.random()-0.5) * 0.8,
                life: 1,
                decay: 0.025 + Math.random() * 0.02,
                size: 0.6 + Math.random() * 0.8,
                color
            });
        }
    }

    update(dt){
        for(let p of this.particles){
            p.x += p.vx * dt * 0.1;
            p.y += p.vy * dt * 0.1;
            p.life -= p.decay * dt * 0.1;
        }
        this.particles = this.particles.filter(p => p.life > 0);
    }

    draw(){
        for(let p of this.particles){
            ctx.globalAlpha = p.life * 0.7;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
}

const trail = new Trail();

// =============================
// PKG ECHO RINGS
// =============================
const pkgEchoRings = [];

function triggerSpawn(x, y){
    // Three staggered echo rings
    pkgEchoRings.push({ x, y, radius: 0, life: 1, delay: 0   });
    pkgEchoRings.push({ x, y, radius: 0, life: 1, delay: 120 });
    pkgEchoRings.push({ x, y, radius: 0, life: 1, delay: 240 });
}

function updateSpawnParticles(dt){
    for(let r of pkgEchoRings){
        if(r.delay > 0){ r.delay -= dt; continue; }
        r.radius += 0.12 * dt;
        r.life   -= 0.0018 * dt;
    }
    for(let i = pkgEchoRings.length - 1; i >= 0; i--)
        if(pkgEchoRings[i].life <= 0) pkgEchoRings.splice(i, 1);
}

function drawSpawnParticles(){
    for(let r of pkgEchoRings){
        if(r.delay > 0 || r.life <= 0) continue;
        ctx.globalAlpha = r.life * 0.7;
        ctx.strokeStyle = '#ffdd88';
        ctx.lineWidth   = 1.5 * r.life;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
}

// =============================
// DUST / PLUME PARTICLE SYSTEM
// =============================
const dustParticles = [];

function emitLandingDust(planet, surfaceAngle){
    const pp = planet.position();
    const sx = pp.x + Math.cos(surfaceAngle) * planet.size;
    const sy = pp.y + Math.sin(surfaceAngle) * planet.size;

    const dustColors = [
        hexToRgba(planet.color, 0.6),
        hexToRgba(planet.color, 0.3),
        'rgba(200,200,200,0.4)',
        'rgba(255,255,255,0.25)',
        hexToRgba(planet.color, 0.15),
    ];

    for(let i = 0; i < 45; i++){
        // Spread dust along the surface tangent (perpendicular to surface normal)
        const tangent = surfaceAngle + Math.PI / 2;
        const spread = (Math.random() - 0.5) * 2.2;
        const outward = 0.3 + Math.random() * 1.8;
        const vx = Math.cos(surfaceAngle) * outward * 0.4 + Math.cos(tangent) * spread;
        const vy = Math.sin(surfaceAngle) * outward * 0.4 + Math.sin(tangent) * spread;

        dustParticles.push({
            x: sx + (Math.random() - 0.5) * 4,
            y: sy + (Math.random() - 0.5) * 4,
            vx, vy,
            life: 1,
            decay: 0.006 + Math.random() * 0.008,
            size: 1.0 + Math.random() * 3.5,
            color: dustColors[Math.floor(Math.random() * dustColors.length)]
        });
    }
}

function emitTakeoffBlast(planet, surfaceAngle){
    const pp = planet.position();
    const sx = pp.x + Math.cos(surfaceAngle) * (planet.size + 2);
    const sy = pp.y + Math.sin(surfaceAngle) * (planet.size + 2);

    // Fiery exhaust colors
    const fireColors = [
        'rgba(255,200,60,0.9)',
        'rgba(255,140,30,0.8)',
        'rgba(255,80,10,0.7)',
        'rgba(255,255,200,0.6)',
        'rgba(255,100,50,0.5)',
    ];

    // Dust kicked up by takeoff
    const dustColors = [
        hexToRgba(planet.color, 0.5),
        'rgba(200,200,200,0.3)',
        hexToRgba(planet.color, 0.2),
    ];

    // Fire blast downward (into planet surface)
    for(let i = 0; i < 35; i++){
        const tangent = surfaceAngle + Math.PI / 2;
        const spread = (Math.random() - 0.5) * 1.5;
        // Particles go inward (opposite of surface normal) to simulate exhaust hitting ground
        const inward = -(0.5 + Math.random() * 2.0);
        const vx = Math.cos(surfaceAngle) * inward * 0.3 + Math.cos(tangent) * spread;
        const vy = Math.sin(surfaceAngle) * inward * 0.3 + Math.sin(tangent) * spread;

        dustParticles.push({
            x: sx + (Math.random() - 0.5) * 3,
            y: sy + (Math.random() - 0.5) * 3,
            vx, vy,
            life: 1,
            decay: 0.008 + Math.random() * 0.012,
            size: 0.8 + Math.random() * 2.5,
            color: fireColors[Math.floor(Math.random() * fireColors.length)]
        });
    }

    // Surface dust blowing outward along tangent
    for(let i = 0; i < 30; i++){
        const tangent = surfaceAngle + Math.PI / 2;
        const dir = Math.random() > 0.5 ? 1 : -1;
        const spread = dir * (0.8 + Math.random() * 2.5);
        const outward = 0.1 + Math.random() * 0.6;
        const vx = Math.cos(surfaceAngle) * outward + Math.cos(tangent) * spread;
        const vy = Math.sin(surfaceAngle) * outward + Math.sin(tangent) * spread;

        dustParticles.push({
            x: sx + (Math.random() - 0.5) * 6,
            y: sy + (Math.random() - 0.5) * 6,
            vx, vy,
            life: 1,
            decay: 0.004 + Math.random() * 0.006,
            size: 1.5 + Math.random() * 3.0,
            color: dustColors[Math.floor(Math.random() * dustColors.length)]
        });
    }
}

function updateDustParticles(dt){
    for(let p of dustParticles){
        p.x += p.vx * dt * 0.08;
        p.y += p.vy * dt * 0.08;
        p.vx *= 0.96;
        p.vy *= 0.96;
        p.life -= p.decay * dt * 0.1;
    }
    for(let i = dustParticles.length - 1; i >= 0; i--)
        if(dustParticles[i].life <= 0) dustParticles.splice(i, 1);
}

function drawDustParticles(){
    for(let p of dustParticles){
        if(p.life <= 0) continue;
        ctx.globalAlpha = p.life * 0.8;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * (0.4 + p.life * 0.6), 0, Math.PI*2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

// =============================
// PACKAGE (spawns on planet)
// =============================
class Package {
    constructor(){
        this.active = false;
        this.planet = null;
        this.surfaceAngle = 0;
        this.bobPhase = Math.random() * Math.PI * 2;
        this.spawnAnim = 0; // 0 to 1 pop-in animation
    }

    spawn(planet, shipSurfaceAngle){
    this.active = true;
    this.planet = planet;
    this.spawnAnim = 0;

    // Fully random angle
    let angle;
    let attempts = 0;

    do {
        angle = Math.random() * Math.PI * 2;
        attempts++;
        // Keep trying if too close to landing site
    } while(
        attempts < 30 &&
        Math.abs(angleDiff(angle, shipSurfaceAngle)) < 0.9   // ~50 degrees away
    );

    this.surfaceAngle = angle;

    // Trigger visible spawn burst on surface
    const pp = planet.position();
    const r = planet.size + 6;

    const sx = pp.x + Math.cos(this.surfaceAngle) * r;
    const sy = pp.y + Math.sin(this.surfaceAngle) * r;

    triggerSpawn(sx, sy);
}


    dismiss(){
        this.active = false;
        this.planet = null;
    }

    update(dt){
        if(!this.active) return;
        this.bobPhase += dt * 0.004;
        if(this.spawnAnim < 1) this.spawnAnim = Math.min(1, this.spawnAnim + dt * 0.004);
    }

    draw(t){
        if(!this.active) return;

        const pp = this.planet.position();
        const r = this.planet.size + 6;
        const bob = Math.sin(this.bobPhase) * 1.5;

        const x = pp.x + Math.cos(this.surfaceAngle) * (r + bob);
        const y = pp.y + Math.sin(this.surfaceAngle) * (r + bob);

        // Eased pop-in scale
        const ease = 1 - Math.pow(1 - this.spawnAnim, 3);
        const scale = ease * 0.22;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(this.surfaceAngle + Math.PI / 2);
        ctx.scale(scale, scale);

        // Glow underneath
        const glow = ctx.createRadialGradient(0, 0, 2, 0, 0, 30);
        glow.addColorStop(0, 'rgba(255,220,80,0.4)');
        glow.addColorStop(1, 'rgba(255,220,80,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, 30, 0, Math.PI * 2);
        ctx.fill();

        // Crate body
        ctx.fillStyle = "#cc8800";
        ctx.strokeStyle = "#aa6600";
        ctx.lineWidth = 2;
        if(ctx.roundRect){
            ctx.beginPath();
            ctx.roundRect(-12, -20, 24, 22, 3);
            ctx.fill();
            ctx.stroke();
        } else {
            ctx.fillRect(-12, -20, 24, 22);
            ctx.strokeRect(-12, -20, 24, 22);
        }

        // Crate highlight
        ctx.fillStyle = "rgba(255,200,0,0.5)";
        ctx.fillRect(-8, -16, 16, 14);

        // Crate cross straps
        ctx.strokeStyle = "#886600";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-12, -20); ctx.lineTo(12, 2);
        ctx.moveTo(12, -20); ctx.lineTo(-12, 2);
        ctx.stroke();

        // Resource icon dot (glowing)
        const resColors = { oxygen:'#00ccff', water:'#4488ff', food:'#44dd77', fuel:'#ffaa00' };
        const rc = resColors[this.planet.resource] || '#fff';
        ctx.fillStyle = rc;
        ctx.shadowColor = rc;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(0, -9, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();
    }
}

const pkg = new Package();

// =============================
// ANGLE UTILS
// =============================
function lerpAngle(current, target, t){
    let diff = target - current;
    while(diff >  Math.PI) diff -= Math.PI * 2;
    while(diff < -Math.PI) diff += Math.PI * 2;
    return current + diff * t;
}

function angleDiff(a, b){
    let d = b - a;
    while(d >  Math.PI) d -= Math.PI * 2;
    while(d < -Math.PI) d += Math.PI * 2;
    return d;
}

// =============================
// SHIP
// =============================
class Ship {
    constructor(){
        const c = center();
        this.x = c.x;
        this.y = c.y - 200;
        this.vx = 0;
        this.vy = 0;
        this.rotation = 0;
        this.thrusting = false;
        // Loading phase
        this.loadingTimer = 0;
        this.loadingResource = null;
        this.loadingDuration = 2000; // 2 seconds

        this.state = "idle";
        this.target = null;
        this.nextTarget = null;   // pre-planned destination decided during loading
        this.landedPlanet = null;
        this.surfaceAngle = 0;

        this.resources = {
            oxygen: randRange(50, 100),
            water:  randRange(50, 100),
            food:   randRange(50, 100),
            fuel:   randRange(50, 100)
        };
        this.integrity = 100;
        this.SUN_DANGER_RADIUS = 90; // replaced by sunDangerRadius() below ‚Äî kept for fallback
        this.evaRefillRate = 0;
        this.evaResource = null;

        // Spawn
        this.spawned = false;
        this.spawnTimer = 0;
        this.SPAWN_DELAY = 1200;

        // Warp-in animation
        this.warpAnim = 0;          // 0 ‚Üí 1 over warpDuration ms
        this.warpDuration = 700;

        // Post-spawn hold before AI engages
        this.holdTimer = 0;
        this.HOLD_DURATION = 4000;

        // Takeoff effect
        this.takeoffTimer = 0;
        this.takeoffBlastEmitted = false;
        this.departureTimer = 0;  // ramps steering strength after takeoff for smooth arc

        // Idle wander
        this.wanderX = 0;
        this.wanderY = 0;
        this._pickWander();
                // Smooth landing
        this.landingProgress = 0;

        // Prevent repeat planet visits
        this.lastPlanet = null;

    }

    _pickWander(){
        // Wander within inner system (roughly between innermost and mid orbits)
        const c = center();
        const wanderRadius = Math.min(canvas.width, canvas.height) / 2 * 0.35 * SOLAR_SCALE;
        const angle = Math.random() * Math.PI * 2;
        const dist  = wanderRadius * (0.3 + Math.random() * 0.7);
        this.wanderX = c.x + Math.cos(angle) * dist;
        this.wanderY = c.y + Math.sin(angle) * dist;
    }

    update(dt){
        // Spawn countdown
        if(!this.spawned){
            this.spawnTimer += dt;
            if(this.spawnTimer >= this.SPAWN_DELAY){
                this.spawned = true;
                triggerSpawn(this.x, this.y);
            }
            return;
        }

        // Warp-in progress
        if(this.warpAnim < 1) this.warpAnim = Math.min(1, this.warpAnim + dt / this.warpDuration);

        // Post-spawn hold
        if(this.holdTimer < this.HOLD_DURATION) this.holdTimer += dt;

        // RESOURCE DRAIN
        let oxygenDrain = 0.0004; // base drain inside ship

        if(this.state === "eva"){
            oxygenDrain = 0.0025; // heavy drain outside
        }
        else if(this.state === "transfer" || this.state === "takeoff"){
            oxygenDrain = 0.0007; // slightly higher under thrust
        }

        this.resources.oxygen -= oxygenDrain * dt;

        this.resources.water -= 0.001 * dt;
        this.resources.food  -= 0.0006 * dt;

        if(this.state === "transfer" || this.state === "takeoff")
            this.resources.fuel -= 0.0015 * dt;


        for(let r in this.resources)
            this.resources[r] = Math.max(0, this.resources[r]);

        // SUN PROXIMITY ‚Äî integrity damage when flying too close
        if(this.state !== "landed" && this.state !== "eva" && this.state !== "loading"){
            const c = center();
            const sunDist = Math.hypot(this.x - c.x, this.y - c.y);
            const sunDangerR = sunDangerRadius();
            if(sunDist < sunDangerR){
                const intensity = 1 - sunDist / sunDangerR;
                this.integrity = Math.max(0, this.integrity - 0.008 * intensity * dt);
            }
        }

        // TRANSFER ‚Äî slow thrust, always tracking moving target
        if(this.state === "transfer"){
            const tp = this.target.position();
            const dx = tp.x - this.x;
            const dy = tp.y - this.y;
            const dist = Math.hypot(dx, dy);
            const angle = Math.atan2(dy, dx);

            const maxSpeed = 1.4;
            const arriveRadius = 120;
            const surfaceDist = Math.max(0, dist - this.target.size);
            let desiredSpeed = surfaceDist < arriveRadius ? maxSpeed * (surfaceDist / arriveRadius) : maxSpeed;
            desiredSpeed = Math.max(desiredSpeed, 0.55);

            const desiredVX = Math.cos(angle) * desiredSpeed;
            const desiredVY = Math.sin(angle) * desiredSpeed;

            // Ramp steering from near-zero to full over 1800ms so the ship
            // arcs naturally out of takeoff rather than snapping to heading.
            this.departureTimer = Math.min(this.departureTimer + dt, 1800);
            const ramp = (this.departureTimer / 1800) ** 2; // ease-in curve
            const steerStrength = Math.min(1, 0.004 * dt) * (0.05 + 0.95 * ramp);

            this.vx += (desiredVX - this.vx) * steerStrength;
            this.vy += (desiredVY - this.vy) * steerStrength;

            this.thrusting = dist > this.target.size + 10;
            if(this.thrusting){
                trail.emit(this.x, this.y, this.vx, this.vy, "#88ccff");
            }

            if(dist <= this.target.size + 8){
                this.land();
            }
        }

        // LANDED / EVA ‚Äî stick to planet surface
        if(this.state === "landed" || this.state === "eva" || this.state === "loading"){
            const pp = this.landedPlanet.position();
            this.x = pp.x + Math.cos(this.surfaceAngle) * this.landedPlanet.size;
            this.y = pp.y + Math.sin(this.surfaceAngle) * this.landedPlanet.size;
            this.rotation = this.surfaceAngle + Math.PI/2;
            this.thrusting = false;
        }
// =============================
// LOADING
// =============================
if(this.state === "loading"){
    this.loadingTimer += dt;

    const progress = this.loadingTimer / this.loadingDuration;

    if(this.loadingResource){
        const type = this.loadingResource;

        if(type === "repair"){
            // Restore integrity instead of a resource
            this.integrity = Math.min(100, this.integrity + 0.06 * dt);
        } else {
            // Gradual refill
            this.resources[type] = Math.min(
                100,
                this.resources[type] + 0.05 * dt
            );
        }
    }

    if(progress >= 1){
        this.loadingResource = null;
        AudioManager.stopLoading();

        // Increment missions counter
        missionsCompleted++;
        const mcEl = document.getElementById('missions-count');
        if(mcEl) mcEl.textContent = missionsCompleted;

        // Player controls the next destination ‚Äî takeoff and wait for input
        // (if player already queued a target via nextTarget, it will be used)
        const dest = ship.nextTarget ? ship.nextTarget.name.toUpperCase() : "NONE";
        dbg(`‚¨Ü LOADING complete ‚Üí TAKEOFF | queued=${dest}`, "state");

        this.state = "takeoff";
    }

    this.thrusting = false;
    this.updateHUD();
    return;
}

        // TAKEOFF
        if(this.state === "takeoff"){
            this.takeoffTimer += dt;

            // Emit the big takeoff blast once at the start
            if(!this.takeoffBlastEmitted){
                this.takeoffBlastEmitted = true;
                emitTakeoffBlast(this.landedPlanet, this.surfaceAngle);
                // Structural stress from launch
                this.integrity = Math.max(0, this.integrity - (1 + Math.random() * 2));

            }

            // Continuous exhaust during takeoff
            if(this.takeoffTimer % 3 < 2){
                const pp = this.landedPlanet.position();
                const ex = pp.x + Math.cos(this.surfaceAngle) * (this.landedPlanet.size - 1);
                const ey = pp.y + Math.sin(this.surfaceAngle) * (this.landedPlanet.size - 1);
                const tangent = this.surfaceAngle + Math.PI / 2;
                for(let i = 0; i < 2; i++){
                    dustParticles.push({
                        x: this.x, y: this.y,
                        vx: -Math.cos(this.surfaceAngle) * (0.5 + Math.random() * 1.5) + (Math.random()-0.5)*0.5,
                        vy: -Math.sin(this.surfaceAngle) * (0.5 + Math.random() * 1.5) + (Math.random()-0.5)*0.5,
                        life: 1,
                        decay: 0.012 + Math.random() * 0.015,
                        size: 0.6 + Math.random() * 1.8,
                        color: ['rgba(255,180,60,0.8)','rgba(255,100,20,0.6)','rgba(255,220,120,0.7)'][Math.floor(Math.random()*3)]
                    });
                }
            }

            this.vx += Math.cos(this.surfaceAngle) * 0.00012 * dt;
            this.vy += Math.sin(this.surfaceAngle) * 0.00012 * dt;
            this.thrusting = true;
            trail.emit(this.x, this.y, this.vx, this.vy, "#ffaa44");

            if(this.distanceTo(this.landedPlanet.position()) > this.landedPlanet.size + 120){
                this.landedPlanet = null;
                this.thrusting = false;
                this.takeoffTimer = 0;
                this.takeoffBlastEmitted = false;

                if(this.nextTarget){
                    // Go directly ‚Äî no idle drift
                    dbg(`üöÄ TAKEOFF complete ‚Üí TRANSFER to ${this.nextTarget.name.toUpperCase()}`, "state");
                    this.target = this.nextTarget;
                    this.nextTarget = null;
                    this.state = "transfer";
                    this.departureTimer = 0;  // start arc ramp
                } else {
                    // Fallback: let chooseNext() pick from idle
                    dbg(`üîÑ TAKEOFF complete ‚Üí IDLE (no pre-planned target)`, "state");
                    this.target = null;
                    this.state = "idle";
                }
            }
        }

        // IDLE WANDER
        if(this.state === "idle"){
            const dx = this.wanderX - this.x;
            const dy = this.wanderY - this.y;
            const dist = Math.hypot(dx, dy);
            if(dist < 30){
                this._pickWander();
            } else {
                const angle = Math.atan2(dy, dx);
                const thrust = 0.00012;
                this.vx += Math.cos(angle) * thrust * dt;
                this.vy += Math.sin(angle) * thrust * dt;
                const spd = Math.hypot(this.vx, this.vy);
                if(spd > 0.18){ this.vx *= 0.18/spd; this.vy *= 0.18/spd; }
            }
            this.thrusting = Math.hypot(this.vx, this.vy) > 0.05;
            if(this.thrusting)
                trail.emit(this.x, this.y, this.vx, this.vy, "#88ccff");
        }

        // PHYSICS
        if(this.state === "transfer" || this.state === "takeoff" || this.state === "idle"){
            this.x += this.vx * dt * 0.1;
            this.y += this.vy * dt * 0.1;
            if(Math.hypot(this.vx, this.vy) > 0.01){
                let targetRotation = Math.atan2(this.vy, this.vx) + Math.PI/2;

                if(this.state === "transfer" && this.target){
                    const tp = this.target.position();
                    const dist = Math.hypot(tp.x - this.x, tp.y - this.y);
                    const blendStart = 120;
                    if(dist < blendStart){
                        const surfAngle = Math.atan2(this.y - tp.y, this.x - tp.x);
                        const landingRot = surfAngle + Math.PI/2;
                        const blend = 1 - dist / blendStart;
                        targetRotation = lerpAngle(targetRotation, landingRot, blend);
                    }
                }

                this.rotation = lerpAngle(this.rotation, targetRotation, Math.min(1, 0.005 * dt));
            }
        }

        // Global speed cap
        const maxSpd = 1.4;
        const spd = Math.hypot(this.vx, this.vy);
        if(spd > maxSpd){ this.vx *= maxSpd/spd; this.vy *= maxSpd/spd; }

        // Keep wander target within the inner system world bounds
        const c2 = center();
        const maxWander = Math.min(canvas.width, canvas.height) / 2 * 0.38 * SOLAR_SCALE;
        const wx = this.wanderX - c2.x, wy = this.wanderY - c2.y;
        if(Math.hypot(wx, wy) > maxWander){
            const wa = Math.atan2(wy, wx);
            this.wanderX = c2.x + Math.cos(wa) * maxWander;
            this.wanderY = c2.y + Math.sin(wa) * maxWander;
        }

        this.updateHUD();
    }

    land(){
        this.state = "landed";
        dbg(`‚úà LANDED on ${this.target.name.toUpperCase()} (resource: ${this.target.resource})`, "state");
        this.landedPlanet = this.target;

        const pp = this.landedPlanet.position();
        this.surfaceAngle = Math.atan2(this.y - pp.y, this.x - pp.x);
        this.x = pp.x + Math.cos(this.surfaceAngle) * this.landedPlanet.size;
        this.y = pp.y + Math.sin(this.surfaceAngle) * this.landedPlanet.size;
        this.vx = 0;
        this.vy = 0;

        // Landing dust plume!
        emitLandingDust(this.landedPlanet, this.surfaceAngle);

        // Impact stress ‚Äî repair planet is a soft dock, others are harder landings
const landingSpeed = Math.hypot(this.vx, this.vy);

// Repair planet absorbs most impact
const impactMultiplier = this.landedPlanet.resource === "repair" ? 1.2 : 3.5;

const impactDmg = landingSpeed * impactMultiplier;

this.integrity = Math.max(0, this.integrity - impactDmg);


        this.evaResource = this.landedPlanet.resource;
        if(this.evaResource === "repair"){
            // Repair planet restores integrity, not a normal resource
            this.evaRefillRate = 0;
        } else {
            const deficit = 100 - this.resources[this.evaResource];
            this.evaRefillRate = deficit / 2000;
        }

        // Spawn a package on the planet
        pkg.spawn(this.landedPlanet, this.surfaceAngle);

        // Deploy astronaut to walk to the package
        astronaut.deploy(this);
    }

    distanceTo(p){ return Math.hypot(this.x - p.x, this.y - p.y); }

    updateHUD(){

    // =============================
    // RESOURCE BARS
    // =============================
    for(let key of ['oxygen','water','food','fuel']){

        const val = Math.round(this.resources[key]);

        const bar   = document.getElementById('bar-' + key);
        const valEl = document.getElementById('val-' + key);
        const rowEl = document.getElementById('row-' + key);

        if(bar)   bar.style.width = val + '%';
        if(valEl) valEl.textContent = val;

        if(rowEl)
            rowEl.classList.toggle('critical', val < 15);

        // Play danger sound when a resource first enters critical
        if(val < 15 && val > 0) AudioManager.playDanger();
        if(bar){
            if(val < 15){
                bar.style.background = 'linear-gradient(90deg,#aa0000,#ff2222)';
            } else {
                const colors = {
                    oxygen: 'linear-gradient(90deg,#0077bb,#00bbff)',
                    water:  'linear-gradient(90deg,#1133aa,#3366ff)',
                    food:   'linear-gradient(90deg,#227744,#44dd77)',
                    fuel:   'linear-gradient(90deg,#aa6600,#ffaa00)',
                };
                bar.style.background = colors[key] || '';
            }
        }

        if(val <= 0 && this.spawned && !gameOver)
            triggerGameOver(key);
    }

    // INTEGRITY BAR
    const intVal = Math.round(this.integrity);
    const intBar   = document.getElementById('bar-integrity');
    const intValEl = document.getElementById('val-integrity');
    const intRowEl = document.getElementById('row-integrity');
    if(intBar){
        intBar.style.width = intVal + '%';
        intBar.style.background = intVal < 20
            ? 'linear-gradient(90deg,#aa0000,#ff2222)'
            : 'linear-gradient(90deg,#7722cc,#cc44ff)';
    }
    if(intValEl) intValEl.textContent = intVal;
    if(intRowEl) intRowEl.classList.toggle('critical', intVal < 20);
    if(intVal < 20 && intVal > 0) AudioManager.playDanger();
    if(intVal <= 0 && this.spawned && !gameOver)
        triggerGameOver('integrity');


    // =============================
    // STATE LABEL
    // =============================
    const stateEl  = document.getElementById('state-label');
    const targetEl = document.getElementById('target-label');

    if(stateEl){
        if(!this.spawned){
            stateEl.textContent = "STANDBY";
        }
        else if(this.state === "loading"){
            const pct = Math.min(
                100,
                Math.floor((this.loadingTimer / this.loadingDuration) * 100)
            );
            const resName = this.loadingResource === "repair"
                ? "HULL"
                : this.loadingResource
                    ? this.loadingResource.toUpperCase()
                    : "CARGO";
            const verb = this.loadingResource === "repair" ? "REPAIRING " : "LOADING ";
            stateEl.textContent = verb + resName + " " + pct + "%";
        }
        else{
            stateEl.textContent = this.state.toUpperCase();
        }
    }
    // =============================
    // TARGET LABEL
    // =============================
    if(targetEl){
        targetEl.textContent =
            this.target ? this.target.name.toUpperCase() : "‚Äî";
    }
}

    draw(){
        if(!this.spawned) return;

        // ‚îÄ‚îÄ Warp-in effect ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if(this.warpAnim < 1){
            const t = this.warpAnim;
            // Ease out: starts fast, settles to normal
            const ease = 1 - Math.pow(1 - t, 3);

            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);

            // Horizontal warp streak ‚Äî wide & thin, collapses to ship
            const streakW = (1 - ease) * 320 + 20;
            const streakH = ease * 22 + (1 - ease) * 2;
            const streakAlpha = (1 - ease) * 0.85;

            // Outer soft streak
            const sg = ctx.createLinearGradient(-streakW, 0, streakW, 0);
            sg.addColorStop(0,   'rgba(100,200,255,0)');
            sg.addColorStop(0.3, `rgba(140,220,255,${streakAlpha * 0.5})`);
            sg.addColorStop(0.5, `rgba(220,240,255,${streakAlpha})`);
            sg.addColorStop(0.7, `rgba(140,220,255,${streakAlpha * 0.5})`);
            sg.addColorStop(1,   'rgba(100,200,255,0)');
            ctx.fillStyle = sg;
            ctx.fillRect(-streakW, -streakH / 2, streakW * 2, streakH);

            // Bright core line
            const cg = ctx.createLinearGradient(-streakW * 0.6, 0, streakW * 0.6, 0);
            cg.addColorStop(0,   'rgba(255,255,255,0)');
            cg.addColorStop(0.5, `rgba(255,255,255,${streakAlpha * 0.9})`);
            cg.addColorStop(1,   'rgba(255,255,255,0)');
            ctx.fillStyle = cg;
            ctx.fillRect(-streakW * 0.6, -1, streakW * 1.2, 2);

            // Flash burst at centre when warp is fresh
            if(t < 0.25){
                const flashAlpha = (0.25 - t) / 0.25;
                const flashR = (1 - t) * 60 + 10;
                const fg = ctx.createRadialGradient(0, 0, 0, 0, 0, flashR);
                fg.addColorStop(0, `rgba(255,255,255,${flashAlpha * 0.9})`);
                fg.addColorStop(0.4, `rgba(160,220,255,${flashAlpha * 0.5})`);
                fg.addColorStop(1,   'rgba(100,180,255,0)');
                ctx.fillStyle = fg;
                ctx.beginPath();
                ctx.arc(0, 0, flashR, 0, Math.PI * 2);
                ctx.fill();
            }

            // Speed lines radiating outward (only early in warp)
            if(t < 0.55){
                const lineAlpha = (0.55 - t) / 0.55;
                ctx.strokeStyle = `rgba(180,230,255,${lineAlpha * 0.6})`;
                ctx.lineWidth = 0.8;
                const lineCount = 10;
                for(let i = 0; i < lineCount; i++){
                    const la = (i / lineCount) * Math.PI * 2;
                    const inner = 12 + (1 - t) * 10;
                    const outer = inner + (1 - t) * 80 * (0.4 + Math.random() * 0.6);
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(la) * inner, Math.sin(la) * inner);
                    ctx.lineTo(Math.cos(la) * outer, Math.sin(la) * outer);
                    ctx.stroke();
                }
            }

            ctx.restore();

            // Fade ship in over the second half of warp
            if(ease < 0.4) return;
            ctx.globalAlpha = (ease - 0.4) / 0.6;
        }
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.scale(0.2, 0.2);

        // Engine glow
        if(this.thrusting){
            const grd = ctx.createRadialGradient(0, 25, 2, 0, 25, 28);
            grd.addColorStop(0, 'rgba(255,180,60,0.9)');
            grd.addColorStop(1, 'rgba(255,80,0,0)');
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(0, 25, 28, 0, Math.PI*2);
            ctx.fill();

            // Enhanced flame during takeoff
            if(this.state === "takeoff"){
                const flameLen = 35 + Math.sin(Date.now() * 0.02) * 10;
                const grd2 = ctx.createRadialGradient(0, 30, 3, 0, 30 + flameLen * 0.5, flameLen);
                grd2.addColorStop(0, 'rgba(255,255,200,0.8)');
                grd2.addColorStop(0.3, 'rgba(255,160,40,0.6)');
                grd2.addColorStop(0.6, 'rgba(255,80,10,0.3)');
                grd2.addColorStop(1, 'rgba(255,40,0,0)');
                ctx.fillStyle = grd2;
                ctx.beginPath();
                ctx.arc(0, 30 + flameLen * 0.3, flameLen, 0, Math.PI * 2);
                ctx.fill();

                // Inner white-hot core
                const coreLen = flameLen * 0.4;
                ctx.fillStyle = 'rgba(255,255,240,0.5)';
                ctx.beginPath();
                ctx.ellipse(0, 28, 5, coreLen, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Body
        ctx.fillStyle = "#dde8f0";
        ctx.beginPath();
        if(ctx.roundRect) ctx.roundRect(-10, -28, 20, 44, 4);
        else ctx.rect(-10, -28, 20, 44);
        ctx.fill();

        // Cockpit
        ctx.fillStyle = "#00ccff";
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.ellipse(0, -18, 7, 10, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Wings
        ctx.fillStyle = "#aabbc8";
        ctx.beginPath();
        ctx.moveTo(-10, 5); ctx.lineTo(-26, 18); ctx.lineTo(-10, 14);
        ctx.closePath(); ctx.fill();
        ctx.beginPath();
        ctx.moveTo(10, 5); ctx.lineTo(26, 18); ctx.lineTo(10, 14);
        ctx.closePath(); ctx.fill();

        // Nozzle
        ctx.fillStyle = "#778899";
        ctx.fillRect(-7, 14, 14, 8);

        ctx.restore();
        ctx.globalAlpha = 1;
    }
}

const ship = new Ship();

// =============================
// ASTRONAUT
// =============================
class Astronaut {
    constructor(){
        this.state = "idle";
        this.planet = null;
        this.surfaceAngle = 0;
        this.targetAngle = 0;
        this.carrying = false;
        this.shipAngle = 0; // remember where the ship is
    }

    deploy(s){
        this.planet = s.landedPlanet;
        this.surfaceAngle = s.surfaceAngle + 0.08; // start just beside the ship
        this.shipAngle = s.surfaceAngle;

        // Walk to the package location
        if(pkg.active){
            this.targetAngle = pkg.surfaceAngle;
        } else {
            this.targetAngle = this.surfaceAngle + 0.6;
        }

        this.state = "walking_out";
        this.carrying = false;
        s.state = "eva";
    }

    update(dt){
        if(this.state === "idle") return;

        // Calculate angle difference properly
            const diff = angleDiff(this.surfaceAngle, this.targetAngle);

            if (Math.abs(diff) < 0.015) {

                if (this.state === "walking_out") {

                    this.carrying = true;
                    pkg.dismiss();

                    this.targetAngle = this.shipAngle;
                    this.state = "walking_back";

                } else if (this.state === "walking_back") {

                    this.carrying = false;
                    this.state = "idle";

                    ship.loadingResource = this.planet.resource;
                    ship.loadingTimer = 0;
                    ship.state = "loading";
                    AudioManager.startLoading();
                }

            } else {

                // Slower walking speed
                const step = angleDiff(this.surfaceAngle, this.targetAngle);
                const walkSpeed = 0.02;      // slowed
                const move = Math.sign(step) * Math.min(Math.abs(step), walkSpeed);

                this.surfaceAngle += move * dt * 0.035; // slowed
            }
        }

    

    draw(t){
        if(this.state === "idle") return;

        const p = this.planet.position();
        const r = this.planet.size + 4;

        const walking = Math.abs(angleDiff(this.surfaceAngle, this.targetAngle)) > 0.02;
        const bob  = walking ? Math.sin(t * 0.015) * 1.2 : 0;
        const lean = walking ? Math.sin(t * 0.008) * 0.07 : 0;

        const x = p.x + Math.cos(this.surfaceAngle) * r;
        const y = p.y + Math.sin(this.surfaceAngle) * r;
        const bobX = -Math.sin(this.surfaceAngle) * bob;
        const bobY =  Math.cos(this.surfaceAngle) * bob;

        ctx.save();
        ctx.translate(x + bobX, y + bobY);
        ctx.rotate(this.surfaceAngle + Math.PI/2 + lean);
        ctx.scale(0.2, 0.2);

        // Helmet
        ctx.fillStyle = "rgba(200,230,255,0.9)";
        ctx.beginPath();
        ctx.arc(0, -14, 9, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "rgba(0,180,255,0.5)";
        ctx.beginPath();
        ctx.arc(0, -14, 6, 0, Math.PI*2);
        ctx.fill();

        // Suit body
        ctx.fillStyle = "#dde8f0";
        ctx.fillRect(-6, -5, 12, 16);

        // Arms
        if(this.carrying){
            // Arms reaching up to hold the crate
            ctx.fillStyle = "#ccd8e4";
            ctx.fillRect(-10, -22, 4, 14);
            ctx.fillRect( 6, -22, 4, 14);
        } else {
            // Swinging arms
            const armSwing = walking ? Math.sin(t * 0.015) * 4 : 0;
            ctx.fillStyle = "#ccd8e4";
            ctx.fillRect(-10, -3 + armSwing, 4, 10);
            ctx.fillRect( 6, -3 - armSwing, 4, 10);
        }

        // Legs with step animation
        if(walking){
            const step = Math.sin(t * 0.015);
            ctx.fillStyle = "#aabbc8";
            ctx.fillRect(-5, 11, 4, 8 + step*3);
            ctx.fillRect( 1, 11, 4, 8 - step*3);

            // Tiny dust puffs at feet
            if(Math.random() > 0.7){
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = "#aaa";
                ctx.beginPath();
                ctx.arc(step > 0 ? -3 : 3, 20, 2 + Math.random()*2, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        } else {
            ctx.fillStyle = "#aabbc8";
            ctx.fillRect(-5, 11, 4, 8);
            ctx.fillRect( 1, 11, 4, 8);
        }

        // Resource crate above head
        if(this.carrying){
            ctx.fillStyle = "#cc8800";
            ctx.strokeStyle = "#aa6600";
            ctx.lineWidth = 1;
            if(ctx.roundRect){
                ctx.beginPath();
                ctx.roundRect(-7, -32, 14, 10, 2);
                ctx.fill();
                ctx.stroke();
            } else {
                ctx.fillRect(-7, -32, 14, 10);
                ctx.strokeRect(-7, -32, 14, 10);
            }
            ctx.fillStyle = "rgba(255,200,0,0.5)";
            ctx.fillRect(-5, -30, 10, 6);

            // Cross straps on crate
            ctx.strokeStyle = "#886600";
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.moveTo(-7, -32); ctx.lineTo(7, -22);
            ctx.moveTo(7, -32); ctx.lineTo(-7, -22);
            ctx.stroke();
        }

        ctx.restore();
    }
}

const astronaut = new Astronaut();

// =============================
// PLAYER NAVIGATION (replaces AI)
// =============================
// Navigation is now driven by player taps/clicks on planets.
// chooseNext() is kept as a no-op so existing call sites don't break.
function chooseNext(){
    // No-op: player controls the ship by clicking planets.
}

// =============================
// RANDOM EVENTS
// =============================
const EVENTS = [
    {
        id: 'solar_flare',
        name: '‚ö° SOLAR FLARE',
        desc: 'Electromagnetic surge scorches the hull',
        color: '#ff8800',
        flashColor: 'rgba(255,140,0,',
        weight: 10,
        apply(s){ s.integrity = Math.max(0, s.integrity - (4 + Math.random() * 6)); },
        condition: (s) => s.state !== 'landed' && s.state !== 'loading',
    },
    {
        id: 'micrometeorite',
        name: '‚òÑ MICROMETEORITE SHOWER',
        desc: 'Hull and fuel tanks punctured',
        color: '#ff4444',
        flashColor: 'rgba(255,60,20,',
        weight: 9,
        apply(s){
            s.integrity = Math.max(0, s.integrity - (3 + Math.random() * 5));
            s.resources.fuel = Math.max(0, s.resources.fuel - (4 + Math.random() * 6));
        },
    },
    {
        id: 'oxygen_leak',
        name: '‚ö† OXYGEN LEAK',
        desc: 'Cracked seal ‚Äî O2 venting into space',
        color: '#00bbff',
        flashColor: 'rgba(0,180,255,',
        weight: 9,
        apply(s){ s.resources.oxygen = Math.max(0, s.resources.oxygen - (8 + Math.random() * 10)); },
    },
    {
        id: 'food_spoilage',
        name: '! BIO-CONTAMINATION',
        desc: 'Ration packs compromised ‚Äî food spoiled',
        color: '#44dd77',
        flashColor: 'rgba(40,180,80,',
        weight: 8,
        apply(s){ s.resources.food = Math.max(0, s.resources.food - (10 + Math.random() * 12)); },
    },
    {
        id: 'water_loss',
        name: '! COOLANT RUPTURE',
        desc: 'Water reserves lost to a fractured pipe',
        color: '#4488ff',
        flashColor: 'rgba(60,100,255,',
        weight: 8,
        apply(s){ s.resources.water = Math.max(0, s.resources.water - (8 + Math.random() * 10)); },
    },
    {
        id: 'fuel_leak',
        name: '! FUEL LEAK',
        desc: 'Thruster valve failure ‚Äî fuel bleeding out',
        color: '#ffaa00',
        flashColor: 'rgba(255,160,0,',
        weight: 9,
        apply(s){ s.resources.fuel = Math.max(0, s.resources.fuel - (10 + Math.random() * 12)); },
    },
    {
        id: 'cosmic_ray',
        name: '‚ò¢ COSMIC RADIATION',
        desc: 'High-energy particles degrade hull plating',
        color: '#cc44ff',
        flashColor: 'rgba(160,40,255,',
        weight: 7,
        apply(s){
            s.integrity = Math.max(0, s.integrity - (3 + Math.random() * 4));
            s.resources.oxygen = Math.max(0, s.resources.oxygen - (3 + Math.random() * 5));
        },
    },
    {
        id: 'solar_wind',
        name: '~ SOLAR WIND GUST',
        desc: 'Ion storm drains fuel reserves',
        color: '#ffdd44',
        flashColor: 'rgba(255,220,40,',
        weight: 8,
        apply(s){ s.resources.fuel = Math.max(0, s.resources.fuel - (6 + Math.random() * 8)); },
        condition: (s) => s.state === 'transfer' || s.state === 'idle',
    },
    {
        id: 'gravity_assist',
        name: '+ GRAVITATIONAL ANOMALY',
        desc: 'Unexpected mass deposits near hull ‚Äî integrity stressed',
        color: '#aa44ff',
        flashColor: 'rgba(140,40,255,',
        weight: 6,
        apply(s){
            s.integrity = Math.max(0, s.integrity - (5 + Math.random() * 8));
            s.resources.fuel = Math.max(0, s.resources.fuel - (3 + Math.random() * 5));
        },
    },
    {
        id: 'good_nebula',
        name: '* NEBULAR NUTRIENTS',
        desc: 'Rich cloud replenishes food and water stores',
        color: '#44ffaa',
        flashColor: 'rgba(40,255,160,',
        weight: 5,
        good: true,
        apply(s){
            s.resources.food  = Math.min(100, s.resources.food  + (8 + Math.random() * 12));
            s.resources.water = Math.min(100, s.resources.water + (6 + Math.random() * 10));
        },
    },
    {
        id: 'good_solar',
        name: '* SOLAR CHARGING',
        desc: 'Solar sails harvest unexpected energy burst',
        color: '#ffee44',
        flashColor: 'rgba(255,230,40,',
        weight: 4,
        good: true,
        apply(s){ s.resources.fuel = Math.min(100, s.resources.fuel + (10 + Math.random() * 14)); },
        condition: (s) => s.state !== 'landed' && s.state !== 'loading',
    },
];

// Screen flash effect
let screenFlash = null;

function triggerScreenFlash(colorStr, intensity){
    screenFlash = { color: colorStr, alpha: intensity || 0.35, decay: 0.012 };
}

function drawScreenFlash(){
    if(!screenFlash) return;
    ctx.save();
    ctx.globalAlpha = screenFlash.alpha;
    ctx.fillStyle = screenFlash.color + '1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
    screenFlash.alpha -= screenFlash.decay;
    if(screenFlash.alpha <= 0) screenFlash = null;
}

function pickEvent(){
    const available = EVENTS.filter(e => !e.condition || e.condition(ship));
    const totalWeight = available.reduce((a,e) => a + e.weight, 0);
    let roll = Math.random() * totalWeight;
    for(let e of available){
        roll -= e.weight;
        if(roll <= 0) return e;
    }
    return available[available.length - 1];
}

let eventTimer = 18000;
const EVENT_INTERVAL_MIN = 20000;
const EVENT_INTERVAL_MAX = 45000;

function updateEvents(dt){
    if(!ship.spawned || gameOver) return;
    eventTimer -= dt;
    if(eventTimer > 0) return;

    const ev = pickEvent();
    if(!ev) return;

    ev.apply(ship);

    showNotif(ev.name, ev.color, 'event-major');
    setTimeout(() => showNotif(ev.desc, ev.good ? '#44ffaa' : '#ff6644'), 600);
    triggerScreenFlash(ev.flashColor, ev.good ? 0.12 : 0.28);
    AudioManager.playWarning();
    dbg('EVENT: ' + ev.name + ' ‚Äî ' + ev.desc, ev.good ? 'good' : 'crit');

    eventTimer = EVENT_INTERVAL_MIN + Math.random() * (EVENT_INTERVAL_MAX - EVENT_INTERVAL_MIN);
}

// =============================
// MINIMAP
// =============================
function drawMinimap(t){
    const mm = 120;  // size
    const mx = canvas.width - mm - 16;
    const my = canvas.height - mm - 16;
    const cr = mm / 2;
    const cc = { x: mx + cr, y: my + cr };

    // Panel bg
    ctx.save();
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = 'rgba(0,5,15,0.9)';
    ctx.strokeStyle = 'rgba(0,170,255,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(cc.x, cc.y, cr, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Clip to circle
    ctx.beginPath();
    ctx.arc(cc.x, cc.y, cr - 2, 0, Math.PI*2);
    ctx.clip();

    // Scale: outermost orbit radius to minimap radius
    const outerOrbitR = Math.min(canvas.width, canvas.height) / 2 * 0.96 * SOLAR_SCALE;
    const mmScale = (cr - 6) / outerOrbitR;

    // Sun
    ctx.fillStyle = '#ffcc00';
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    ctx.arc(cc.x, cc.y, 3, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Planets
    const pColors = { oxygen:'#00bbff', water:'#4488ff', food:'#44dd77', fuel:'#ffaa00', repair:'#cc44ff' };
    for(let p of planets){
        const pp = p.position();
        const c  = center();
        const px = cc.x + (pp.x - c.x) * mmScale;
        const py = cc.y + (pp.y - c.y) * mmScale;
        ctx.fillStyle = pColors[p.resource] || '#fff';
        ctx.globalAlpha = 0.85;
        ctx.beginPath();
        ctx.arc(px, py, 3, 0, Math.PI*2);
        ctx.fill();
        // Orbit ring (faint)
        ctx.globalAlpha = 0.1;
        ctx.strokeStyle = pColors[p.resource] || '#fff';
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        ctx.arc(cc.x, cc.y, p.orbitRadius() * mmScale, 0, Math.PI*2);
        ctx.stroke();
    }

    // Ship
    if(ship.spawned){
        const c = center();
        const sx = cc.x + (ship.x - c.x) * mmScale;
        const sy = cc.y + (ship.y - c.y) * mmScale;
        ctx.globalAlpha = 1;
        ctx.fillStyle = '#fff';
        ctx.shadowColor = '#0af';
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(sx, sy, 2, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    ctx.restore();

    // Border label
    ctx.save();
    ctx.font = "7px 'Share Tech Mono'";
    ctx.fillStyle = 'rgba(0,170,255,0.35)';
    ctx.textAlign = 'center';
    ctx.letterSpacing = '2px';
    ctx.fillText('NAV', cc.x, my + mm + 10);
    ctx.restore();
}

// =============================
// GAME OVER
// =============================
let gameOver = false;
const RESOURCE_NAMES = { oxygen:'OXYGEN', water:'WATER', food:'FOOD', fuel:'FUEL', integrity:'HULL INTEGRITY' };

function triggerGameOver(resource){
    gameOver = true;
    AudioManager.playEnding();
    document.getElementById('gameover-reason').textContent =
        RESOURCE_NAMES[resource] + ' DEPLETED ‚Äî CREW LOST';
    const scoreEl = document.getElementById('gameover-score');
    if(scoreEl) scoreEl.textContent = `MISSIONS COMPLETED: ${missionsCompleted}`;
    document.getElementById('gameover').classList.add('active');
}

// =============================
// MAIN LOOP (only runs after start)
// =============================
let last = 0;
function loop(t){
    if(gameOver) return;
    if(!gameStarted) return;
    const dt = Math.min(t - last, 50) * speedMultiplier;
    last = t;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Nebula + Stars ‚Äî screen-fixed, no camera transform
    drawNebula();
    drawStars(t);

    // Smooth zoom toward target
    camera.zoom += (camera.targetZoom - camera.zoom) * Math.min(1, 0.06 * dt / 16);

    // World ‚Äî apply camera
    if(camera.follow && ship.spawned){
        const targetPanX = (canvas.width  / 2 - ship.x) * camera.zoom;
        const targetPanY = (canvas.height / 2 - ship.y) * camera.zoom;
        const lerpSpeed = Math.min(1, 0.08 * dt / 16);
        camera.panX += (targetPanX - camera.panX) * lerpSpeed;
        camera.panY += (targetPanY - camera.panY) * lerpSpeed;
    }

    ctx.save();
    applyCamera();

    drawSun(t);

    for(let p of planets){ p.update(dt); p.draw(t); }

    // Loading ring around the landed planet
    if(ship.state === "loading" && ship.landedPlanet){
        const lp = ship.landedPlanet;
        const lpos = lp.position();
        const progress = Math.min(1, ship.loadingTimer / ship.loadingDuration);
        const ringR = lp.size + 10;
        const resColors2 = { oxygen:'#00bbff', water:'#4488ff', food:'#44dd77', fuel:'#ffaa00', repair:'#cc44ff' };
        const rc = resColors2[lp.resource] || '#0af';
        // Background ring
        ctx.globalAlpha = 0.2;
        ctx.strokeStyle = rc;
        ctx.lineWidth = 3 / camera.zoom;
        ctx.beginPath();
        ctx.arc(lpos.x, lpos.y, ringR, 0, Math.PI*2);
        ctx.stroke();
        // Progress arc
        ctx.globalAlpha = 0.9;
        ctx.strokeStyle = rc;
        ctx.lineWidth = 2.5 / camera.zoom;
        ctx.shadowColor = rc;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.arc(lpos.x, lpos.y, ringR, -Math.PI/2, -Math.PI/2 + progress * Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
    }

    trail.update(dt);
    trail.draw();

    updateSpawnParticles(dt);
    drawSpawnParticles();

    updateDustParticles(dt);
    drawDustParticles();

    ship.update(dt);
    astronaut.update(dt);
    pkg.update(dt);
    chooseNext();
    updateEvents(dt);
    if(camera.follow) updatePlanetNavHighlight();

    // Oxygen warning monitor
    if(ship.spawned && !gameOver){
        const oxy = ship.resources.oxygen;
        const now2 = performance.now();
        if(oxy < 30 && (now2 - lastOxyWarn) > 3000){
            lastOxyWarn = now2;
            const lvl = oxy < 10 ? 'crit' : oxy < 20 ? 'warn' : 'info';
            dbg(`‚ö† O2 WARNING: ${oxy.toFixed(0)}% ‚Äî state=${ship.state}${ship.target ? ' target='+ship.target.name : ''}`, lvl);
        }
    }

    // Draw package before ship/astronaut so it's behind them
    pkg.draw(t);
    ship.draw();
    astronaut.draw(t);

    ctx.restore();

    // ‚îÄ‚îÄ Screen flash (events) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    drawScreenFlash();

    requestAnimationFrame(loop);
}

// =============================
// BACKGROUND STARFIELD FOR START SCREEN
// =============================
// Render a gentle animated starfield behind the start screen
function startBgLoop(t){
    if(gameStarted) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawNebula();
    drawStars(t);
    requestAnimationFrame(startBgLoop);
}
// =============================
// AUDIO SYSTEM
// =============================
const AudioManager = {
    muted: false,
    started: false,
    _userInteracted: false,       // true after first user click (Launch)
    loopAudio: null,
    warnAudio: null,
    confirmAudio: null,
    dangerAudio: null,
    endingAudio: null,
    loadingAudio: null,
    warpAudio: null,
    _wasPlayingBeforeHidden: false,
    _dangerCooldown: 0,           // timestamp of last danger play
    _isLoadingPlaying: false,     // track loading sound state

    init() {
        // ‚îÄ‚îÄ Create audio elements ‚îÄ‚îÄ
        this.loopAudio = new Audio('loop.mp3');
        this.loopAudio.loop = true;
        this.loopAudio.volume = 0.4;

        this.warnAudio = new Audio('warning.mp3');
        this.warnAudio.volume = 0.6;
        this.confirmAudio = new Audio('confirm.mp3');
        this.confirmAudio.volume = 0.5;

        this.dangerAudio = new Audio('danger.mp3');
        this.dangerAudio.volume = 0.55;
        this.endingAudio = new Audio('ending.mp3');
        this.endingAudio.volume = 0.7;

        this.loadingAudio = new Audio('loading.mp3');
        this.loadingAudio.volume = 0.45;
        this.loadingAudio.loop = true;   // loops while loading

        this.warpAudio = new Audio('warp.mp3');
        this.warpAudio.volume = 0.6;

        // ‚îÄ‚îÄ Visibility change: pause/resume when tab hidden ‚îÄ‚îÄ
        // Works on PC (all browsers), Android Chrome, iOS Safari
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                this._pauseAll();
            } else {
                this._resumeAll();
            }
        });

        // Extra insurance for iOS ‚Äî blur/focus on window
        window.addEventListener('blur', () => this._pauseAll());
        window.addEventListener('focus', () => this._resumeAll());

        // iOS Safari: pageshow/pagehide for app switching & tab switching
        window.addEventListener('pagehide', () => this._pauseAll());
        window.addEventListener('pageshow', () => this._resumeAll());

        // Mute button wiring
        const muteBtn = document.getElementById('mute-btn');
        muteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleMute();
        });
        muteBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.toggleMute();
        });
    },

    // Called when user clicks Launch ‚Äî unlocks audio context
    onUserInteract() {
        this._userInteracted = true;
        document.getElementById('mute-btn').style.display = 'flex';
    },

    startLoop() {
        if (this.started) return;
        this.started = true;
        if (!this.muted) {
            const p = this.loopAudio.play();
            if (p && p.catch) p.catch(() => {});
        }
    },

    // ‚îÄ‚îÄ One-shot SFX helpers ‚îÄ‚îÄ
    _playOneShot(audio) {
        if (this.muted) return;
        const sfx = audio.cloneNode();
        sfx.volume = audio.volume;
        const p = sfx.play();
        if (p && p.catch) p.catch(() => {});
    },

    playWarning() {
        if (!this.started) return;
        this._playOneShot(this.warnAudio);
    },

    playConfirm() {
        if (!this.started) return;
        this._playOneShot(this.confirmAudio);
    },

    // Danger: plays when a resource goes critical, with 4s cooldown
    playDanger() {
        if (!this.started || this.muted) return;
        const now = performance.now();
        if (now - this._dangerCooldown < 4000) return;
        this._dangerCooldown = now;
        this._playOneShot(this.dangerAudio);
    },

    // Ending: plays on death, stops the loop
    playEnding() {
        this.loopAudio.pause();
        this.stopLoading();
        if (this.muted) return;
        const p = this.endingAudio.play();
        if (p && p.catch) p.catch(() => {});
    },

    // Loading: looping sound that plays while Jed loads resources
    startLoading() {
        if (this._isLoadingPlaying || this.muted) return;
        this._isLoadingPlaying = true;
        this.loadingAudio.currentTime = 0;
        const p = this.loadingAudio.play();
        if (p && p.catch) p.catch(() => {});
    },

    stopLoading() {
        if (!this._isLoadingPlaying) return;
        this._isLoadingPlaying = false;
        this.loadingAudio.pause();
        this.loadingAudio.currentTime = 0;
    },

    // Warp: plays during title screen launch, before game loop starts
    playWarp() {
        if (this.muted || !this._userInteracted) return;
        this._playOneShot(this.warpAudio);
    },

    toggleMute() {
        this.muted = !this.muted;
        const btn = document.getElementById('mute-btn');
        if (this.muted) {
            this.loopAudio.pause();
            this.loadingAudio.pause();
            btn.textContent = 'üîá';
            btn.classList.add('muted');
        } else {
            btn.textContent = 'üîä';
            btn.classList.remove('muted');
            if (this.started && !document.hidden) {
                const p = this.loopAudio.play();
                if (p && p.catch) p.catch(() => {});
            }
            // Resume loading sound if we're mid-load
            if (this._isLoadingPlaying) {
                const p = this.loadingAudio.play();
                if (p && p.catch) p.catch(() => {});
            }
        }
    },

    _pauseAll() {
        this._wasPlayingBeforeHidden = !this.loopAudio.paused;
        this.loopAudio.pause();
        this.loadingAudio.pause();
    },

    _resumeAll() {
        if (this.muted) return;
        if (this._wasPlayingBeforeHidden) {
            const p = this.loopAudio.play();
            if (p && p.catch) p.catch(() => {});
        }
        if (this._isLoadingPlaying) {
            const p = this.loadingAudio.play();
            if (p && p.catch) p.catch(() => {});
        }
    }
};

AudioManager.init();

requestAnimationFrame(startBgLoop);
</script>
</body>
</html>